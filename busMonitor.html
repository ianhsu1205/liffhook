<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>車輛查核</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/uuid/8.3.2/uuid.min.js"></script>
    <script src="https://static.line-scdn.net/liff/edge/2/sdk.js"></script>
    <style>
      body {
        font-family: "Noto Sans TC", Arial, sans-serif;
        background-color: #f7f7f7;
        margin: 0;
        padding: 0;
        color: #000;
      }

      .container {
        max-width: 500px;
         margin: 0 auto; /* 修改為0 auto使頂部無間距 */
        background: white;
        padding: 25px;
        border-radius: 12px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
      }

      h2 {
        margin-top: 10px; /* 減少上邊距 */
        color: #06c755;
        text-align: center;
        margin-bottom: 25px;
        font-weight: 600;
     border-bottom: none; /* 移除底部分隔線 */
        padding-bottom: 15px;
      }
/* 車輛距離黃白漸層底色樣式 */
.bus-plate.distance-veryclose { 
  background: linear-gradient(to right, #ffeb3b 100%, #ffffff 100%);
  border: 1px solid #ffc107;
}

.bus-plate.distance-close { 
  background: linear-gradient(to right, #ffeb3b 75%, #ffffff 75%);
  border: 1px solid #ffd54f;
}

.bus-plate.distance-medium { 
  background: linear-gradient(to right, #ffeb3b 50%, #ffffff 50%);
  border: 1px solid #ffe082;
}

.bus-plate.distance-far { 
  background: linear-gradient(to right, #ffeb3b 25%, #ffffff 25%);
  border: 1px solid #ffecb3;
}

/* 自動偵測按鈕啟動樣式 */
.utility-button.auto-detect-active {
  background-color: #06c755 !important;
  color: white !important;
  border-color: #04a73e !important;
  box-shadow: 0 0 8px rgba(6, 199, 85, 0.5) !important;
  transform: translateY(-2px) !important;
  position: relative;
  animation: pulse 1.5s infinite;
}
      .form-group {
        margin-bottom: 20px;
        text-align: left;
      }

      label {
        display: block;
        margin-bottom: 6px;
        font-weight: 500;
        color: #555;
      }

      .required::after {
        content: "*";
        color: #e74c3c;
        margin-left: 4px;
      }

      /* 輸入框樣式 */
      .input-group {
        display: flex;
        align-items: center;
      }

      .input-group input {
        flex: 1;
        border-top-right-radius: 0;
        border-bottom-right-radius: 0;
      }

      .input-group .icon-button {
        width: 46px;
        height: 46px;
        border: 1px solid #ddd;
        border-left: none;
        background-color: #f8f9fa;
        border-top-right-radius: 6px;
        border-bottom-right-radius: 6px;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        transition: background-color 0.2s;
      }

      .input-group .icon-button:hover {
        background-color: #e9ecef;
      }

      .input-group .icon-button i {
        color: #06c755;
      }

      input,
      select,
      textarea {
        width: 100%;
        padding: 12px;
        border: 1px solid #ddd;
        border-radius: 6px;
        font-size: 16px;
        transition: border 0.3s;
        box-sizing: border-box;
      }

      input:focus,
      select:focus,
      textarea:focus {
        border-color: #06c755;
        outline: none;
        box-shadow: 0 0 0 2px rgba(6, 199, 85, 0.1);
      }

      /* 新增：檢測車輛卡片樣式 */
      .bus-card {
        background-color: #fff;
        border-radius: 8px;
        border: 1px solid #ddd;
        margin-bottom: 15px;
        overflow: hidden;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        transition: all 0.3s ease;
      }

      .bus-card:hover {
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      }

      .bus-card-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 15px;
        background-color: #f8f9fa;
        border-bottom: 1px solid #eee;
      }

      .bus-card-company {
        font-weight: bold;
        color: #06c755;
      }

      .bus-card-plate {
        font-weight: bold;
        background-color: #ffeb3b;
        padding: 3px 8px;
        border-radius: 4px;
      }

      .bus-card-body {
        padding: 15px;
      }

      .bus-card-route {
        margin-bottom: 10px;
        font-size: 15px;
      }

      .bus-card-actions {
        display: flex;
        flex-direction: column;
        gap: 10px;
        margin-top: 10px;
      }

      button {
        width: 100%;
        padding: 14px;
        background-color: #06c755;
        color: white;
        border: none;
        border-radius: 6px;
        font-size: 18px;
        font-weight: 500;
        cursor: pointer;
        transition: 0.3s;
        margin-top: 10px;
      }

      button:hover {
        background-color: #04a73e;
        box-shadow: 0 4px 8px rgba(6, 199, 85, 0.2);
      }

      .secondary-button {
        background-color: #f1f1f1;
        color: #333;
      }

      .secondary-button:hover {
        background-color: #e5e5e5;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      }

      /* 簡化選項樣式 */
      .quick-items {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-bottom: 10px;
      }

      .quick-item {
  background-color: #f1f1f1;
  border-radius: 20px;
  padding: 8px 14px; /* 放大按鈕尺寸 */
  font-size: 15px; /* 放大字體 */
  cursor: pointer;
  border: 1px solid #ddd;
  transition: all 0.2s ease;
  margin-bottom: 5px; /* 增加間距 */
      }

      .quick-item.selected {
  background-color: #06c755;
  color: white;
  border-color: #04a73e;
  box-shadow: 0 2px 6px rgba(6, 199, 85, 0.3);
  transform: translateY(-2px);
  position: relative;
  font-weight: bold;
      }
      .quick-item.selected::after {
  content: "✓";
  position: absolute;
  top: -8px;
  right: -8px;
  background-color: #04a73e;
  color: white;
  font-size: 12px;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  border: 2px solid white;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}
      /* 其他項目簡化樣式 */
      .quick-other-items {
  touch-action: pan-y; /* 允許垂直滑動，但不影響水平滑動 */
      }
      .swipe-container, 
.content-container {
  width: 100%;
  overflow: hidden;
  position: relative;
}
      .quick-other-item {
  touch-action: manipulation;
  -webkit-tap-highlight-color: transparent;
  position: relative;
      }
      /* 修正滑動容器問題 */
.category-pages {
  display: block;
  width: 100%;
}
      .quick-other-item.selected {
  background-color: #e7f3fe;
  color: #004085;
  border-color: #b8daff;
  border-width: 2px;
  font-weight: bold;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
  transform: translateY(-2px);
      }
/* 為其他項目添加選中標記 */
.quick-other-item.selected::after {
  content: "✓";
  position: absolute;
  top: -8px;
  right: -8px;
  background-color: #007bff;
  color: white;
  font-size: 12px;
  width: 18px;
  height: 18px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  border: 2px solid white;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}
      .status-message {
        margin-top: 15px;
        padding: 10px;
        border-radius: 5px;
        text-align: center;
        display: none;
      }

      .status-message.success {
        background-color: #d4edda;
        color: #155724;
        display: block;
      }

      .status-message.error {
        background-color: #f8d7da;
        color: #721c24;
        display: block;
      }

      .status-message.info {
        background-color: #e7f3fe;
        color: #004085;
        display: block;
      }

      /* 即時偵測結果小卡 */
      .real-time-detection {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background-color: #06c755;
        color: white;
        padding: 10px 15px;
        border-radius: 30px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        z-index: 99;
        display: flex;
        align-items: center;
        gap: 10px;
        opacity: 0;
        transform: translateY(20px);
        transition: all 0.3s ease;
        cursor: pointer;
      }

      .real-time-detection.show {
        opacity: 1;
        transform: translateY(0);
      }

      .detection-count {
        background-color: white;
        color: #06c755;
        font-weight: bold;
        border-radius: 50%;
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      
      /* 動作按鈕樣式 */
      .action-button {
        padding: 10px;
        border-radius: 4px;
        text-align: center;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
      }
      
      .submit-button {
        background-color: #06c755;
        color: white;
      }
      
      .submit-button:hover {
        background-color: #04a73e;
      }
      
      .remove-button {
        background-color: #f8d7da;
        color: #721c24;
      }
      
      .remove-button:hover {
        background-color: #f5c6cb;
      }
      
 @media (max-width: 480px) {
    .utility-buttons {
      grid-template-columns: repeat(3, 1fr);
    }
  }
.utility-buttons {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 8px;
  margin: 15px 0;
}
      .utility-button {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 10px 8px;
  border-radius: 6px;
  background-color: #f1f1f1;
  color: #333;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  border: 1px solid #ddd;
  gap: 5px;
  touch-action: manipulation;
  -webkit-tap-highlight-color: transparent;
      }
      
      .utility-button:hover {
        background-color: #e5e5e5;
      }
      .utility-button i {
  font-size: 18px;
  margin-bottom: 4px;
}
      .utility-button.primary {
        background-color: #e7f3fe;
        color: #004085;
        border-color: #b8daff;
      }
      
      .utility-button.primary:hover {
        background-color: #d1e7ff;
      }
      
      /* 無檢測結果時的樣式 */
      .no-buses-message {
  text-align: center;
  padding: 30px 0; /* 只保留上下內邊距，左右邊距設為0 */
  background-color: #f8f9fa;
  border-radius: 8px;
  color: #6c757d;
  margin: 20px 0;
  width: 100%;
  box-sizing: border-box;
  display: block; /* 確保是塊級元素 */
      }
      /* 確保內部文字左右有適當距離 */
.no-buses-message p {
  padding: 0 20px;
  margin: 0;
}
           
      /* 查詢歷史樣式 */
      .history-list {
        margin-top: 15px;
      }
      
      .history-item {
        padding: 10px;
        border-bottom: 1px solid #eee;
        display: flex;
        justify-content: space-between;
      }
      
      .history-time {
        color: #6c757d;
        font-size: 12px;
      }
      
      /* 狀態標籤 */
      .status-tag {
        display: inline-block;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 12px;
        font-weight: 500;
        margin-left: 5px;
      }
      
      .status-processing {
        background-color: #fff3cd;
        color: #856404;
      }
      
      .status-submitted {
        background-color: #d4edda;
        color: #155724;
      }
      
      /* 位置項目樣式 */
      .location-item {
        padding: 12px;
        border-bottom: 1px solid #eee;
        cursor: pointer;
      }
      
      .location-item:hover {
        background-color: #f9f9f9;
      }
      
      /* 檢測按鈕容器樣式 */
      .detect-button-container {
  margin-bottom: 15px;
  text-align: center;
  display: flex;
  gap: 10px;
  justify-content: center;
      }
      
      .detect-button {
  width: auto !important;
  padding: 10px 15px !important;
  margin: 0 !important;
  flex: 1;
      }
     #onBoardInspectionButton {
  background-color: #f8f9fa;
  color: #333;
}

#onBoardInspectionButton:hover {
  background-color: #e9ecef;
} 
      /* 無數據提示樣式 */
      .no-data-message {
        text-align: center;
        padding: 15px;
        color: #6c757d;
        font-style: italic;
      }
      
      /* 彈窗模態樣式補充 */
      .modal {
        display: none;
        position: fixed;
        z-index: 100;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        animation: fadeIn 0.3s ease;
      }
      
      @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
      }
      
      .modal-content {
        background-color: #fefefe;
        margin: 15% auto;
        padding: 20px;
        border-radius: 10px;
        width: 80%;
        max-width: 500px;
        max-height: 70vh;
        overflow-y: auto;
        animation: slideDown 0.3s ease;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      }
      
      @keyframes slideDown {
        from { transform: translateY(-50px); opacity: 0; }
        to { transform: translateY(0); opacity: 1; }
      }
      
      .button-group {
        display: flex;
        gap: 10px;
        margin-top: 20px;
      }
      
      /* 載入中覆蓋層樣式補充 */
      .loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(255, 255, 255, 0.9);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 2000;
      }
      
      .spinner {
        width: 40px;
        height: 40px;
        border: 4px solid #f3f3f3;
        border-top: 4px solid #06c755;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }
      
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
      
      .hidden {
        display: none;
      }
      
      /* 公司信息與品牌 */
      .line-brand {
        text-align: center;
        margin-top: 20px;
        font-size: 14px;
        color: #999;
        padding-top: 15px;
        border-top: 1px solid #f0f0f0;
      }
      
      /* 檢測結果區域 */
      .detected-buses-container {
        margin-top: 20px;
        margin-bottom: 20px;
      }
      
      .detection-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
  flex-wrap: wrap;
      }
      .detection-title-area {
  display: flex;
  align-items: center;
}
      
      .detection-header h3 {
        margin: 0;
        color: #06c755;
      }
      /* 簡易車輛列表樣式 */
.simple-bus-list {
    display: grid;
    grid-template-columns: repeat(2, 1fr); /* 改回固定的2列佈局 */
    gap: 10px;
    margin-top: 15px;
}
/* 路線容器固定寬度 */
.bus-route-container {
  width: 125px;            /* 固定寬度 */
  overflow: hidden;    
  white-space: nowrap;
  position: relative;
  margin-right: 0px;      /* 右側間距 */
}
.simple-bus-item {
  background-color: #f8f9fa;
  border: 1px solid #eee;
  border-radius: 6px;
  display: flex;
  justify-content: flex-start;  /* 改為從左開始排列 */
  align-items: center;
  width: 100%;
  padding: 8px 6px;
  box-sizing: border-box;
  margin: 0;
  min-height: 45px;
  overflow: hidden;
    height: 45px; /* 固定高度 */
  margin-bottom: 0;
  transform: translate3d(0, 0, 0); /* 啟用硬體加速，減少重繪 */
  transition: transform 0.2s ease, background-color 0.2s ease;
}
button, .utility-button, .quick-item, .simple-bus-item {
  touch-action: manipulation;
  -webkit-tap-highlight-color: transparent;
}
.simple-bus-item strong {
  font-size: 15px; /* 車牌號碼稍微大一點 */
}

.simple-bus-item:hover {
  background-color: #e7f3fe;
  border-color: #b8daff;
  transform: translateY(-2px);
  box-shadow: 0 3px 6px rgba(0, 0, 0, 0.1);
}
/* 添加到您的CSS中 */
@font-face {
  font-family: 'FontAwesome';
  font-display: swap; /* 改善字體載入 */
}
.company-label {
 color: #06c755;
  font-weight: 500;
  font-size: 15px; /* 減小公司名稱字體 */
}
/* 然後在媒體查詢中處理響應式 */
@media (min-width: 481px) {
  .simple-bus-list {
    grid-template-columns: repeat(2, 1fr); /* 大螢幕使用2列 */
  }
}

@media (max-width: 480px) {
  .simple-bus-list {
    grid-template-columns: repeat(2, 1fr); /* 小螢幕仍保持2列 */
  }
}

@media (max-width: 320px) {
  .simple-bus-list {
    grid-template-columns: 1fr; /* 只有在非常小的螢幕(320px以下)才使用單列 */
  }
}
#detectedBusesList {
  padding: 0;
  margin: 0;
  width: 100%;
}
/* 固定輸入區域樣式 */
.bus-input-container {
  background-color: #fff;
  border: 1px solid #ddd;
  border-radius: 8px;
  margin-top: 20px;
  margin-bottom: 20px;
  box-shadow: 0 3px 8px rgba(0, 0, 0, 0.08);
  overflow: hidden;
  transition: all 0.3s ease;
}
.bus-route {
  color: #004085;
  font-weight: 500;
  font-size: 15px;
  max-width: 70%;
  overflow: hidden;
  white-space: nowrap;
  position: relative;
}
.bus-plate {
  flex-shrink: 0;
  width: 65px !important; /* 固定統一寬度 */
  min-width: 65px !important;
  max-width: 65px !important;
  text-align: center;
  background-color: #ffeb3b;
  padding: 3px 4px;
  border-radius: 4px;
  font-weight: bold;
  font-size: 14px;
  margin-left: 4px;
  white-space: nowrap;
  overflow: hidden; /* 過長時隱藏 */
}

.bus-info-header {
  background-color: #f8f9fa;
  padding: 15px;
  border-bottom: 1px solid #eee;
}

.route-info {
  color: #004085; /* 加深顏色讓路線更明顯 */
  margin-top: 0;
  margin-bottom: 5px;
  font-size: 18px;
  font-weight: 500; /* 加粗 */
  text-align: left; /* 添加這行使文字靠左 */
}

.input-section {
  padding: 15px;
    overflow-x: hidden; /* 防止水平溢出 */
}
  * {
    touch-action: manipulation; /* 優化觸控體驗 */
  }
.input-actions {
  display: flex;
  gap: 10px;
  margin-top: 15px;
}

.cancel-button {
  background-color: #f1f1f1;
  color: #333;
}

.cancel-button:hover {
  background-color: #e5e5e5;
}

/* 倒數計時容器 */
.countdown-container {
    text-align: center;
    margin-top: 8px;
    margin-bottom: 8px;
    color: #06c755;
    font-size: 14px;
    font-weight: bold;
}
/* 開關按鈕樣式 */
.switch-container {
  display: flex;
  align-items: center;
  margin-left: 10px;
  font-size: 14px;
}

.switch {
  position: relative;
  display: inline-block;
  width: 40px;
  height: 20px;
  margin-right: 6px;
}

.switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #ccc;
  transition: .4s;
  border-radius: 34px;
}

.slider:before {
  position: absolute;
  content: "";
  height: 16px;
  width: 16px;
  left: 2px;
  bottom: 2px;
  background-color: white;
  transition: .4s;
  border-radius: 50%;
}

input:checked + .slider {
  background-color: #06c755;
}

input:checked + .slider:before {
  transform: translateX(20px);
}
 /* 添加到現有樣式的最後 */
  /* 跑馬燈效果樣式 */
  .text-marquee {
  display: inline-block;
  white-space: nowrap;
  overflow: hidden;
  width: 100%;
  color: #004085;
  font-weight: 500;
  flex: 1;
  will-change: transform; /* 優化硬體加速 */
  transform: translateZ(0); /* 啟用硬體加速 */
  }
  
.text-marquee.scrolling {
  animation: marquee-transform var(--scroll-duration, 15s) linear infinite;
  animation-fill-mode: forwards;
  backface-visibility: hidden; /* 減少渲染層 */
  contain: paint; /* 告訴瀏覽器只需重新繪製此元素 */
}
/* 優化的跑馬燈動畫，使用 transform 而非 left/right */
@keyframes marquee-transform {
  0% { transform: translateX(0); }
  100% { transform: translateX(-100%); }
}
/* 列表項中的跑馬燈速度更快 */
.list-marquee.scrolling {
  position: relative;
  width: auto;
  padding-left: 0;
  animation: continuous-scroll-transform 15s linear infinite;
  white-space: nowrap;
  backface-visibility: hidden;
  contain: paint;
}
/* 優化的連續滾動動畫 */
@keyframes continuous-scroll-transform {
  0% { transform: translateX(100%); }
  100% { transform: translateX(-100%); }
}
/* 對於低效能設備的備選方案 */
@media (prefers-reduced-motion: reduce) {
  .text-marquee.scrolling,
  .list-marquee.scrolling {
    animation: none; /* 禁用動畫 */
    text-overflow: ellipsis; /* 使用省略號 */
  }
}
/* 添加額外空間，確保文本之間有適當間距 */
.list-marquee.scrolling::after {
content: "　"; /* 使用單個全角空格作為間隔 */
}
  .text-marquee:hover {
    animation-play-state: paused;
  }
  :root {
  --character-scroll-speed: 0.7s; /* 每個字符滾動所需時間 */
}
  .text-marquee:hover {
    animation-play-state: paused;
  }
  :root {
  --character-scroll-speed: 0.7s; /* 每個字符滾動所需時間 */
}
@keyframes continuous-scroll {
  0% { transform: translateX(100%); }    /* 從完全隱藏的右側開始 */
  100% { transform: translateX(-100%); }  /* 滾動到左側結束 */
}
    @keyframes marquee-scroll {
    0% { transform: translateX(0); }
    100% { transform: translateX(-100%); }
  }
  
  /* 調整路線顯示容器 */
  .route-info {
  color: #004085;
  margin-top: 0;
  margin-bottom: 5px;
  font-size: 18px;
  font-weight: 500;
  text-align: left;
  width: 100%;
  overflow: hidden;
  }
  
  /* 確保跑馬燈容器寬度正確 */
  #inputBusRoute {
  width: 100%;
  overflow: hidden;
  position: relative;
  }
/* 響應式調整 */
@media (max-width: 480px) {
  .switch-container {
    font-size: 12px;
  }
  
  .switch {
    width: 36px;
    height: 18px;
  }
  
  .slider:before {
    height: 14px;
    width: 14px;
  }
  
  input:checked + .slider:before {
    transform: translateX(18px);
  }
}

/* 添加脈動動畫效果 */
@keyframes pulse {
  0% { box-shadow: 0 0 0 0 rgba(6, 199, 85, 0.7); }
  70% { box-shadow: 0 0 0 10px rgba(6, 199, 85, 0); }
  100% { box-shadow: 0 0 0 0 rgba(6, 199, 85, 0); }
}

/* 倒數計時文字樣式 */
.countdown-container {
  font-weight: bold;
  color: #06c755;
}
.action-button.disabled {
    opacity: 0.7;
    pointer-events: none;
    cursor: not-allowed;
}
.simple-bus-item.selected-bus-item {
  border: 2px solid #06c755;
  background-color: rgba(6, 199, 85, 0.1);
  position: relative;
}

.simple-bus-item.selected-bus-item::after {
  content: "編輯中";
  position: absolute;
  top: -8px;
  right: -8px;
  background-color: #06c755;
  color: white;
  font-size: 10px;
  padding: 2px 6px;
  border-radius: 10px;
}
 /* 位置精度指示器樣式 */
  .location-accuracy-container {
    margin-top: 5px;
    font-size: 12px;
  }
  
  .location-accuracy {
    display: flex;
    align-items: center;
    gap: 5px;
  }
  .utility-button.detecting {
  background-color: #ffeb3b !important;
  color: #333 !important;
  border-color: #ffc107 !important;
  box-shadow: 0 0 8px rgba(255, 193, 7, 0.7) !important;
  position: relative;
  animation: detecting-pulse 1.5s infinite;
}
/* 添加脈動動畫效果 */
@keyframes detecting-pulse {
  0% { box-shadow: 0 0 0 0 rgba(255, 193, 7, 0.7); }
  70% { box-shadow: 0 0 0 10px rgba(255, 193, 7, 0); }
  100% { box-shadow: 0 0 0 0 rgba(255, 193, 7, 0); }
}
/* 偵測指示器樣式 */
.detection-indicator {
  position: fixed;
  bottom: 70px;
  left: 50%;
  transform: translateX(-50%);
  background-color: rgba(0, 0, 0, 0.7);
  color: white;
  padding: 8px 15px;
  border-radius: 20px;
  font-size: 14px;
  z-index: 1000;
  display: flex;
  align-items: center;
  gap: 8px;
  opacity: 0;
  transition: opacity 0.3s;
  pointer-events: none;
}
.detection-indicator.active {
  opacity: 1;
}

.detection-indicator .spinner {
  width: 16px;
  height: 16px;
  border: 2px solid rgba(255, 255, 255, 0.3);
  border-top: 2px solid #fff;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}
.direction-badge {
  display: inline-block;
  background-color: #007bff;
  color: white;
  border-radius: 3px;
  padding: 0 3px;
  margin-right: 3px;
  font-size: 12px;
  line-height: 1.5;
}

.direction-tag {
  display: inline-block;
  background-color: #e7f3fe;
  color: #004085;
  border-radius: 4px;
  padding: 2px 6px;
  font-size: 14px;
  flex-shrink: 0; /* 防止被壓縮 */
  margin-left: 10px;
}

.route-direction-container {
  display: flex;
  justify-content: space-between;
  align-items: center;
  width: 100%;
  flex-direction: row; /* 確保水平排列 */
}
/* 去程 - 藍色系 */
.bus-plate.direction-go {
  border-left: 8px solid #007bff !important;
}

/* 返程 - 綠色系 */
.bus-plate.direction-back {
  border-left: 8px solid #28a745 !important;
}
.direction-buttons {
  display: flex;
  gap: 10px;
  margin-top: 5px;
}

.direction-btn {
  background-color: #f8f9fa;
  color: #333;
  border: 1px solid #ddd;
  position: relative;
  overflow: hidden;
}

.direction-btn.selected {
  background-color: #e9ecef;
  box-shadow: inset 0 0 10px rgba(0,0,0,0.1);
}
.direction-legend {
  display: flex;
  gap: 10px;
  margin-left: 10px;
  font-size: 12px;
}

.direction-tag.go-tag {
  background-color: #007bff;
  color: white;
}

.direction-tag.back-tag {
  background-color: #28a745;
  color: white;
}
.direction-btn[data-value="0"] {
  border-left: 5px solid #007bff;
}
.direction-btn[data-value="1"] {
  border-left: 5px solid #28a745;
}
.direction-btn.selected[data-value="0"] {
  border-left: 5px solid #007bff;
  background-color: #cfe2ff; /* 淺藍底 */
}

.direction-btn.selected[data-value="1"] {
  border-left: 5px solid #28a745;
  background-color: #d1e7dd; /* 淺綠底 */
}
/* 編輯標籤容器樣式 */
.editing-tabs-container {
  display: flex;
  flex-wrap: nowrap;
  overflow-x: auto;
  gap: 5px;
  padding: 10px 5px;
  background-color: #f8f9fa;
  border-bottom: 1px solid #ddd;
  margin-top: 15px;
  scrollbar-width: thin;
  -webkit-overflow-scrolling: touch;
}

/* 隱藏水平滾動條但保持功能 */
.editing-tabs-container::-webkit-scrollbar {
  height: 4px;
}

.editing-tabs-container::-webkit-scrollbar-thumb {
  background-color: rgba(0,0,0,0.2);
  border-radius: 4px;
}

/* 編輯標籤樣式 */
.editing-tab {
  display: flex;
  align-items: center;
  padding: 8px 12px;
  background-color: #e9ecef;
  border-radius: 20px;
  font-size: 14px;
  white-space: nowrap;
  cursor: pointer;
  transition: all 0.2s ease;
  max-width: 150px;
  overflow: hidden;
  flex-shrink: 0;
}

.editing-tab.active {
  background-color: #06c755;
  color: white;
}

.editing-tab .tab-company {
  margin-left: 5px;
  opacity: 0.7;
  font-size: 12px;
}

.editing-tab .tab-close {
  margin-left: 8px;
  width: 18px;
  height: 18px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  background-color: rgba(0,0,0,0.1);
  font-size: 16px;
  line-height: 1;
  transition: all 0.2s ease;
}

.editing-tab.active .tab-close {
  background-color: rgba(255,255,255,0.2);
}

.editing-tab .tab-close:hover {
  background-color: rgba(255,0,0,0.2);
}
.floating-notification {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%) translateY(100px);
  background-color: rgba(0, 0, 0, 0.8);
  color: white;
  padding: 12px 20px;
  border-radius: 8px;
  z-index: 2000;
  transition: transform 0.3s ease;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  text-align: center;
  max-width: 90%;
}
.floating-notification.show {
  transform: translateX(-50%) translateY(0);
}

.floating-notification.success {
  background-color: rgba(6, 199, 85, 0.9);
}

.floating-notification.error {
  background-color: rgba(220, 53, 69, 0.9);
}
.postpone-button {
  background-color: #6c757d;
  color: white;
}

.postpone-button:hover {
  background-color: #5a6268;
  box-shadow: 0 4px 8px rgba(108, 117, 125, 0.2);
}
/* 分類導航樣式 */
.category-nav {
  display: flex;
  gap: 8px;
  overflow-x: auto;
  padding: 5px 0;
  margin-bottom: 8px;
  scrollbar-width: none; /* 隱藏 Firefox 滾動條 */
  -ms-overflow-style: none; /* 隱藏 IE/Edge 滾動條 */
  -webkit-overflow-scrolling: touch; /* 提高滾動流暢度 */
}

.category-nav::-webkit-scrollbar {
  display: none; /* 隱藏 Chrome/Safari 滾動條 */
}

.category-tab {
  padding: 6px 15px;
  background-color: #f8f9fa;
  border: 1px solid #ddd;
  border-radius: 20px;
  font-size: 14px;
  white-space: nowrap;
  cursor: pointer;
  transition: all 0.2s ease;
  flex-shrink: 0; /* 防止標籤被壓縮 */
}

.category-tab.active {
  background-color: #06c755 !important;
  color: white !important;
  border-color: #06c755 !important;
}

/* 滑動容器樣式 */
.swipe-container {
  width: 100%;
  overflow: hidden;
  position: relative;
}

.swipe-wrapper {
  display: flex;
  transition: transform 0.3s ease;
}

.swipe-page {
  min-width: 100%;
  flex-shrink: 0;
}

/* 滑動指示器樣式 */
.swipe-indicators {
  display: flex;
  justify-content: center;
  gap: 6px;
  margin-top: 10px;
}

.swipe-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background-color: #ddd;
  transition: all 0.2s ease;
}

.swipe-dot.active {
  background-color: #06c755;
  transform: scale(1.2);
}

/* 正向和負向項目的樣式 */
.quick-other-item.positive-item {
  border-left: 3px solid #28a745;
}

.quick-other-item.negative-item {
  border-left: 3px solid #dc3545;
}

.quick-other-item.positive-item.selected {
  background-color: #d4edda;
  color: #155724;
  border-color: #28a745;
}
.quick-other-item.positive-item.selected::after {
  background-color: #28a745;
}
.quick-other-item.negative-item.selected {
  background-color: #f8d7da;
  color: #721c24;
  border-color: #dc3545;
}
.quick-other-item.negative-item.selected::after {
  background-color: #dc3545;
}
.category-page {
  width: 100%;
  min-width: auto;
  flex-shrink: 0;
  position: relative;
}
/* 增加觸控區域優化 */
.category-tab, 
.quick-other-item, 
.quick-item {
  touch-action: manipulation;
  -webkit-tap-highlight-color: transparent;
  position: relative;
}
.category-tab::before, 
.quick-other-item::before, 
.quick-item::before {
    pointer-events: auto !important; 
  touch-action: auto !important;
  content: '';
  position: absolute;
  top: -8px;
  left: -8px;
  right: -8px;
  bottom: -8px;
  z-index: 1;
}
/* 確保內容包裹容器正確布局 */
.category-page > div {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  padding: 5px 0;
}
/* 標籤上的項目計數標記樣式 */
.tab-item-count {
  display: inline-block;
  background-color: #06c755;
  color: white;
  border-radius: 50%;
  width: 18px;
  height: 18px;
  font-size: 11px;
  line-height: 18px;
  text-align: center;
  margin-left: 5px;
  font-weight: bold;
}
.editing-tab.active .tab-item-count {
  background-color: rgba(255,255,255,0.3);
}
/* 編輯區車號旁的計數標記樣式 */
#editingItemCountBadge {
  display: inline-block;
  background-color: #06c755;
  color: white;
  border-radius: 50%;
  width: 20px;
  height: 20px;
  font-size: 12px;
  line-height: 20px;
  text-align: center;
  font-weight: bold;
  margin-left: 5px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}
    </style>
  </head>
<body style="overscroll-behavior-y: contain;">
    <!-- 在 body 開始位置添加返回LINE按鈕 -->
    <div id="loading-overlay" class="loading-overlay hidden">
      <div class="spinner"></div>
    </div>

    <div class="container">
      <h2>車輛查核</h2>

      <div id="statusMessage" class="status-message"></div>

      <!-- 即時偵測懸浮顯示 -->
      <div
        id="realTimeDetection"
        class="real-time-detection"
        onclick="showDetectedBuses()"
      >
        <span id="detectionCount" class="detection-count">0</span>
        <span>個新偵測結果</span>
      </div>

      <!-- 位置選擇 -->
      <div class="form-group">
        <label for="location" class="required">我的位置</label>
        <div class="input-group">
          <input type="text" id="location" placeholder="選擇所在位置" />
          <div class="icon-button" onclick="openLocationModal()">
            <i class="fas fa-map-marker-alt"></i>
          </div>
        </div>
      </div>

<div class="utility-buttons">
  <div class="utility-button" onclick="detectBuses()">
    <i class="fas fa-search"></i>
    <span>偵測車輛</span>
  </div>
  <div id="autoDetectButton" class="utility-button" onclick="toggleAutoDetect()">
    <i class="fas fa-sync"></i>
    <span id="autoDetectStatus">自動偵測</span>
  </div>
  <div class="utility-button" onclick="openManualInputModal()">
    <i class="fas fa-plus"></i>
    <span>手動新增</span>
  </div>

</div>
<div class="countdown-container">
  <span id="countdown"></span>
</div>

      <!-- 隱藏欄位 -->
      <input type="hidden" id="positionLat" />
      <input type="hidden" id="userId" />

      <!-- 檢測到的車輛容器 -->
<div id="detectedBusesContainer" class="detected-buses-container">
  <div class="detection-header">
    <div class="detection-title-area">
      <h3>偵測到的車輛：</h3>
      
      <div class="switch-container">
        <!-- <label class="switch">
          <input type="checkbox" id="includeRecordedToggle" onchange="toggleIncludeRecorded()">
          <span class="slider"></span>
        </label>
        <span>顯示3分鐘內已記錄的車輛</span>
      </div> -->
    </div>
    <span id="busCount" class="status-tag status-processing">0 輛</span>
        <div class="direction-legend">
      <span class="direction-tag go-tag">去</span>
      <span class="direction-tag back-tag">返</span>
    </div>
  </div>
  <div id="detectedBusesList">
    <!-- 檢測到的車輛卡片將在這裡動態顯示 -->
    <div class="no-buses-message">
      <i
        class="fas fa-bus"
        style="font-size: 24px; color: #adb5bd; margin-bottom: 10px"
      ></i>
      <p>尚未檢測到車輛，請點擊「偵測車輛」按鈕</p>
    </div>
  </div>
</div>
 <!-- 修改固定的車輛輸入區域結構，調整路線顯示位置 -->
<div id="busInputContainer" class="bus-input-container hidden">
  <div class="bus-info-header">
    <!-- 將路線移到頂部 -->
    <div id="inputBusRoute" class="route-info"></div>
    <div><span id="inputBusCompany" class="company-label"></span> <strong id="inputBusNumber"></strong></div>
  </div>
  
  <div class="input-section">
    <label>重點查核:</label>
    <div id="mainItemsContainer" class="quick-items">
      <!-- 主要項目將在這裡生成 -->
    </div>
    
    <label>其它:</label>
    <div id="otherItemsContainer" class="quick-other-items">
      <!-- 其他項目將在這裡生成 -->
    </div>
    
    <div class="input-actions">
      <div class="action-button submit-button" onclick="submitSelectedBus()">
        <i class="fas fa-check"></i> 送出記錄
      </div>
        <div class="action-button postpone-button" onclick="postponeEditing()">
    <i class="fas fa-clock"></i> 等下編輯
   </div>
      <div class="action-button cancel-button" onclick="cancelBusInput()">
        <i class="fas fa-times"></i> 取消
      </div>
    </div>
  </div>
</div>
<!-- 修改確認對話框模態窗口 -->
<div id="confirmModal" class="modal">
  <div class="modal-content">
    <h3>確認</h3>
    <p id="confirmMessage">是否取消對此車輛的編輯？</p>
    <div class="button-group">
      <button type="button" id="confirmYes">確認</button>
      <button type="button" class="secondary-button" id="confirmNo">取消</button>
    </div>
  </div>
</div>
<!-- 手動輸入車輛模態框 -->
<div id="manualInputModal" class="modal">
  <div class="modal-content">
    <h3>手動新增車輛</h3>
       <div id="manualInputError" class="status-message error" style="display: none; margin-bottom: 15px;"></div>
    <div class="form-group">
      <label for="manualPlateNumber" class="required">車號</label>
      <input type="text" id="manualPlateNumber" placeholder="輸入車號" oninput="convertToUpperCase(this)" onblur="formatPlateNumber(this)">
    </div>
    <div class="form-group">
      <label for="manualCompany">公司</label>
      <select id="manualCompany"  class="required">
        <option value="">請選擇公司</option>
        <option value="首都客運">首都</option>
        <option value="臺北客運">臺北</option>
        <option value="大都會客運">大都會</option>
        <option value="三重客運">三重</option>
        <option value="台中客運">台中</option>
      </select>
    </div>
    <div class="form-group">
      <label for="manualRoute">路線</label>
      <input type="text" id="manualRoute" placeholder="輸入路線">
    </div>
    <div class="form-group">
  <label for="manualDirection">方向</label>
  <div class="direction-buttons">
    <button type="button" class="direction-btn" data-value="0">去程</button>
    <button type="button" class="direction-btn" data-value="1">返程</button>
  </div>
  <input type="hidden" id="manualDirection" value="0">
</div>
    <div class="button-group">
      <button type="button" onclick="addManualBus()">確認新增</button>
      <button type="button" class="secondary-button" onclick="closeManualInputModal()">取消</button>
    </div>
  </div>
</div>
      <div class="line-brand">多功能平台-車輛查核-v1.1.5.6(瀏覽器模式)
        <div style="font-size: 12px; margin-top: 5px;">
    GPS精準度已強化，請確保開啟位置服務
  </div>
      </div>
    </div>

    <!-- 位置選擇彈窗 -->
    <div id="locationModal" class="modal">
      <div class="modal-content">
        <h3>我的位置</h3>
        <!-- 添加重新偵測按鈕 -->
        <div id="detectLocationButtonContainer" class="detect-button-container">
          <button
            id="detectLocationButton"
            type="button"
            class="secondary-button detect-button"
            onclick="refreshLocationList()"
          >
            <i class="fas fa-sync-alt"></i> 路口
          </button>
            <!-- 新增隨車稽查按鈕 -->
      <button
        id="onBoardInspectionButton"
        type="button"
        class="secondary-button detect-button"
        onclick="selectOnBoardInspection()"
      >
        <i class="fas fa-bus"></i> 隨車
      </button>
            <button
        id="detectAddressButton"
        type="button"
        class="secondary-button detect-button"
        onclick="detectAddress()"
      >
        <i class="fas fa-map-marked-alt"></i> 地址
      </button>
        </div>
        <div id="locationList"></div>
        <div class="button-group">
          <button type="button" onclick="closeLocationModal()">關閉</button>
        </div>
      </div>
    </div>


    <!-- 歷史紀錄彈窗 -->
    <div id="historyModal" class="modal">
      <div class="modal-content">
        <h3>今日紀錄</h3>
        <div id="historyList" class="history-list">
          <!-- 歷史紀錄將在這裡動態顯示 -->
        </div>
        <div class="button-group">
          <button type="button" onclick="closeHistoryModal()">關閉</button>
        </div>
      </div>
    </div>
<!-- 添加偵測指示器元素到頁面底部 -->
<div id="detectionIndicator" class="detection-indicator">
  <div class="spinner"></div>
  <span id="detectionMessage">正在偵測車輛...</span>
</div>

 <script>
// 全局變數
const base_url = "https://35.221.146.143.nip.io/linehook/";
const channelId = "2006992891";
let currentLatitude = 0;
let currentLongitude = 0;
let intersections = [];
let allDetectedBuses = []; // 所有偵測到的車輛
let displayedBuses = []; // 目前顯示的車輛
let submittedBuses = []; // 已新增的車輛
let otherItems = [];
let globalLoadingTimeout = null;
let watchId = null;
let isProcessingBus = false;
let startY = 0;
let lastLoadingTime = 0;
// 其他全局變量
let editingBuses = []; // 儲存所有正在編輯中的車輛
let activeEditingBusIndex = -1; // 當前活躍的編輯車輛索引
const MIN_LOADING_INTERVAL = 30000; // 最短loading間隔，毫秒
let lastBackPressTime = 0;
let autoDetectInterval = null;
let countdownInterval = null;
let selectedBus = null; // 保存選中車輛的完整副本
let countdownSeconds = 20; // 預設20秒
let includeRecordedVehicles = false;
let currentSwipePage = 0;
let pagesContainer = null;
let categoryNav = null;
let totalPages = 0;
let backButtonHandlingDelay = false;
// 初始定義主要查核項目
const mainItems = ["正常", "車輛髒污", "駕駛不良", "車內異味", "服務態度差"];

// 位置保存和加載
function savePosition(latitude, longitude) {
  try {
    localStorage.setItem("lastLatitude", latitude.toString());
    localStorage.setItem("lastLongitude", longitude.toString());
    localStorage.setItem("lastPositionTimestamp", Date.now().toString());
    return true;
  } catch (e) {
    console.error("無法保存位置:", e);
    return false;
  }
}

function loadLastPosition() {
  try {
    const lastLat = localStorage.getItem("lastLatitude");
    const lastLng = localStorage.getItem("lastLongitude");
    
    if (lastLat && lastLng) {
      currentLatitude = parseFloat(lastLat);
      currentLongitude = parseFloat(lastLng);
      return true;
    }
    return false;
  } catch (e) {
    console.error("無法加載上次位置:", e);
    return false;
  }
}

// 初始化函數
function initApp() {
    // 檢測瀏覽器兼容性
  checkBrowserCompatibility();
  // 初始化用戶 ID
  const userId = localStorage.getItem("userId") || uuid.v4();
  document.getElementById("userId").value = userId;
  
  // 加載上次位置
  loadLastPosition();
  
  // 設置事件委托
  setupEventDelegation();
  
  // 初始化通知系統
  NotificationSystem.init();
  
  // 初始化 LIFF (LINE Frontend Framework)
  initializeLIFF();
  
  // 獲取車輛查核項目
  fetchCheckItems();
  
  // 檢查並恢復草稿
  checkAndRestoreDrafts();
  
  // 啟動定位
  getCurrentPosition();
}

// 添加兼容性檢測函數
function checkBrowserCompatibility() {
  // 創建警告容器
  let warningShown = false;
  const showWarning = (message) => {
    if (warningShown) return;
    warningShown = true;
    
    showFloatingNotification(
      `警告: ${message}，部分功能可能受限`,
      "warning",
      8000
    );
  };
  
  // 檢測 geolocation API
  if (!navigator.geolocation) {
    console.warn('瀏覽器不支持地理位置功能');
    showWarning('瀏覽器不支持地理位置功能');
  }
  
  // 檢測 localStorage
  try {
    const testKey = '_test_compat_';
    localStorage.setItem(testKey, '1');
    localStorage.removeItem(testKey);
  } catch (e) {
    console.warn('瀏覽器不支持或禁用了本地存儲');
    showWarning('瀏覽器不支持或禁用了本地存儲');
  }
  
  // 檢測 IntersectionObserver
  if (!('IntersectionObserver' in window)) {
    console.warn('瀏覽器不支持 IntersectionObserver，使用降級方案');
    
    // 降級實現
    window.IntersectionObserver = function(callback) {
      this.observe = function(element) {
        // 簡單實現：當元素進入視口時觸發回調
        setTimeout(() => {
          callback([{
            isIntersecting: true,
            target: element
          }]);
        }, 100);
      };
      this.unobserve = function() {};
      this.disconnect = function() {};
    };
  }
  
  // 檢測 requestIdleCallback
  if (!('requestIdleCallback' in window)) {
    console.warn('瀏覽器不支持 requestIdleCallback，使用 setTimeout 替代');
    window.requestIdleCallback = function(callback) {
      return setTimeout(function() {
        const start = Date.now();
        callback({
          didTimeout: false,
          timeRemaining: function() {
            return Math.max(0, 50 - (Date.now() - start));
          }
        });
      }, 1);
    };
    
    window.cancelIdleCallback = function(id) {
      clearTimeout(id);
    };
  }
  
  // 檢測 Touch API
  if (!('ontouchstart' in window)) {
    console.warn('設備可能不支持觸控功能');
  }
}
// 添加檢查草稿的函數
function checkAndRestoreDrafts() {
  try {
    // 檢查未完成的編輯
    const pendingEdits = localStorage.getItem('pending_edits');
    if (pendingEdits) {
      try {
        const edits = JSON.parse(pendingEdits);
        if (Array.isArray(edits) && edits.length > 0) {
          // 只恢復24小時內的編輯
          const validEdits = edits.filter(edit => (Date.now() - edit.timestamp) < 24 * 60 * 60 * 1000);
          
          if (validEdits.length > 0) {
            // 詢問用戶是否恢復編輯
            setTimeout(() => {
              if (confirm(`發現${validEdits.length}個未完成的車輛編輯，是否恢復？`)) {
                // 恢復編輯
                validEdits.forEach(edit => {
                  // 創建虛擬車輛對象
                  const bus = {
                    plateNumber: edit.plateNumber,
                    uniqueId: edit.uniqueId,
                    selectedMainItem: edit.selectedMainItem,
                    selectedOtherItems: edit.selectedOtherItems,
                    operatorName: "恢復的編輯",
                    routeName: { chinese: "未知路線" },
                    isManualInput: true
                  };
                  
                  // 添加到編輯列表
                  if (!editingBuses.some(b => b.uniqueId === bus.uniqueId)) {
                    editingBuses.push(bus);
                  }
                });
                
                // 設置當前活躍編輯
                if (editingBuses.length > 0) {
                  activeEditingBusIndex = 0;
                  updateEditingTabs();
                  updateBusEditingInterface();
                  document.getElementById("busInputContainer").classList.remove("hidden");
                  
                  showFloatingNotification(`已恢復${validEdits.length}個未完成的編輯`, "success");
                }
              } else {
                // 用戶拒絕恢復，清除編輯
                localStorage.removeItem('pending_edits');
              }
            }, 1000);
          } else {
            // 無有效編輯，清除
            localStorage.removeItem('pending_edits');
          }
        }
      } catch (e) {
        console.error('解析未完成編輯失敗:', e);
        localStorage.removeItem('pending_edits');
      }
    }
    
    // 檢查單個草稿
    const draftKeys = Object.keys(localStorage).filter(key => key.startsWith('draft_'));
    if (draftKeys.length > 0) {
      // 處理單個草稿...
      console.log(`發現${draftKeys.length}個草稿記錄`);
    }
  } catch (e) {
    console.error('檢查草稿失敗:', e);
  }
}

// 初始化 LIFF
function initializeLIFF() {
  if (!liff) {
    console.error("LIFF SDK 未載入");
    return;
  }
  
  liff.init({ liffId: "YOUR_LIFF_ID" })
    .then(() => {
      if (liff.isLoggedIn()) {
        // 獲取用戶資料
        return liff.getProfile();
      } else {
        // 未登入，跳轉到登入頁面
        liff.login();
      }
    })
    .then(profile => {
      if (profile) {
        document.getElementById("userId").value = profile.userId;
      }
    })
    .catch(err => console.error("LIFF 初始化錯誤:", err));
}
// 安全的存儲 API
const safeStorage = {
  get: function(key, defaultValue = null) {
    try {
      const value = localStorage.getItem(key);
      return value !== null ? value : defaultValue;
    } catch (e) {
      console.error(`無法獲取 ${key} 的值:`, e);
      return defaultValue;
    }
  },
  
  set: function(key, value) {
    try {
      localStorage.setItem(key, value);
      return true;
    } catch (e) {
      console.error(`無法設置 ${key} 的值:`, e);
      return false;
    }
  },
  
  remove: function(key) {
    try {
      localStorage.removeItem(key);
      return true;
    } catch (e) {
      console.error(`無法刪除 ${key}:`, e);
      return false;
    }
  },
  
  clearExpired: function(prefix, expiryTime) {
    try {
      const now = Date.now();
      const keysToRemove = [];
      
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith(prefix)) {
          const timestamp = parseInt(localStorage.getItem(key));
          if (now - timestamp > expiryTime) {
            keysToRemove.push(key);
          }
        }
      }
      
      keysToRemove.forEach(key => localStorage.removeItem(key));
      return keysToRemove.length;
    } catch (e) {
      console.error("清理過期項目時出錯:", e);
      return 0;
    }
  }
};
// 顯示加載指示器
function showLoading() {
  const loadingOverlay = document.getElementById("loading-overlay");
  if (loadingOverlay) {
    loadingOverlay.classList.remove("hidden");
  }
  
  // 防止多次重複顯示
  if (globalLoadingTimeout) {
    clearTimeout(globalLoadingTimeout);
    globalLoadingTimeout = null;
  }
  
  // 最長顯示時間
  globalLoadingTimeout = setTimeout(() => {
    hideLoading();
    showStatusMessage("操作超時，請重試", "warning");
  }, 30000);
}

// 隱藏加載指示器
function hideLoading() {
  if (globalLoadingTimeout) {
    clearTimeout(globalLoadingTimeout);
    globalLoadingTimeout = null;
  }
  
  const loadingOverlay = document.getElementById("loading-overlay");
  if (loadingOverlay) {
    loadingOverlay.classList.add("hidden");
  }
}

// 顯示狀態消息
function showStatusMessage(message, type = "info", autoHide = false) {
  const statusElement = document.getElementById("statusMessage");
  if (!statusElement) return;
  
  statusElement.textContent = message;
  statusElement.className = "status-message";
  statusElement.classList.add(type);
  statusElement.style.display = "block";
  
  if (autoHide) {
    setTimeout(() => {
      statusElement.style.display = "none";
    }, 5000);
  }
}
// 定期清理過期的提交記錄
function cleanupExpiredSubmissions() {
  const cleared = safeStorage.clearExpired("submitted_", 3 * 60 * 60 * 1000); // 3小時過期
  console.log(`已清理 ${cleared} 條過期提交記錄`);
}

// 在程式中使用 BusManager 而非直接操作全局變量
function addNewDetectedBus(bus) {
  // 初始化 BusManager 並同步全局數據
  const manager = BusManager.init();
  
  // 使用 BusManager 添加車輛
  const added = manager.addBus(bus);
  
  // 同步回全局變量
  manager.syncToGlobal();
  
  return added;
}

function handleBusSelection(bus, index) {
  // 使用 BusManager 處理選擇
  const manager = BusManager.init();
  manager.addToEditing(bus, index);
  manager.syncToGlobal();
  
  // 更新 UI
  updateBusEditingInterface();
}
// 每小時運行一次清理
setInterval(cleanupExpiredSubmissions, 60 * 60 * 1000);
// 獲取查核項目
function fetchCheckItems() {
  showLoading();
  fetchWithRetry(`${base_url}monitor/check-items`, {}, 3)
    .then(response => response.json())
    .then(data => {
      if (data && data.items) {
        otherItems = data.items;
      }
      hideLoading();
    })
    .catch(error => {
      console.error("獲取查核項目失敗:", error);
      hideLoading();
      showStatusMessage("獲取查核項目失敗，請重新載入頁面", "error", true);
    });
}

// 當文檔加載完成時初始化應用
document.addEventListener('DOMContentLoaded', initApp);
// 新增事件管理工具，用於統一管理事件監聽器，避免重複添加和內存洩漏
const EventManager = {
  listeners: {},
  
  // 添加事件監聽器並記錄
  add: function(element, eventType, callback, options) {
    if (!element) return false;
    
    const id = element.id || `elem_${Math.random().toString(36).substr(2, 9)}`;
    if (!element.id) element.id = id;
    
    const key = `${id}_${eventType}`;
    
    // 如果已存在此事件，先移除
    this.remove(element, eventType);
    
    // 添加新事件並記錄
    element.addEventListener(eventType, callback, options);
    this.listeners[key] = {
      element: element,
      callback: callback
    };
    
    return true;
  },
  
  // 移除事件監聽器
  remove: function(element, eventType) {
    if (!element) return false;
    
    const id = element.id;
    if (!id) return false;
    
    const key = `${id}_${eventType}`;
    const listener = this.listeners[key];
    
    if (listener) {
      element.removeEventListener(eventType, listener.callback);
      delete this.listeners[key];
      return true;
    }
    
    return false;
  },
  
  // 清理特定元素的所有事件
  cleanElement: function(element) {
    if (!element || !element.id) return;
    
    const id = element.id;
    
    Object.keys(this.listeners).forEach(key => {
      if (key.startsWith(id + '_')) {
        const eventType = key.split('_')[1];
        this.remove(element, eventType);
      }
    });
  }
};

// 改進的滑動設置函數，使用 EventManager 管理事件
function setupSwipeFeature(container, navBar, totalCategoryPages) {
  pagesContainer = container;
  categoryNav = navBar;
  totalPages = totalCategoryPages;
  currentSwipePage = 0; // 重置為第一頁
  
  if (!pagesContainer || !categoryNav) return;
  
  // 應用初始頁面設置
  updateSwipePageDisplay(0);
  
  // 設置新的事件處理
  let startX, startY;
  let isScrollingVertical = false;
  let initialTarget = null; // 記錄觸摸開始的元素
  
  // 使用 EventManager 添加觸摸開始事件
  EventManager.add(pagesContainer, 'touchstart', function(e) {
    // 記錄初始觸摸的目標元素
    initialTarget = e.target;
    
    // 如果初始觸摸是在項目元素上，則不啟動滑動
    if (initialTarget.closest('.quick-other-item')) {
      startX = null;
      return;
    }
    
    startX = e.touches[0].clientX;
    startY = e.touches[0].clientY;
    isScrollingVertical = false;
    
    // 設置過渡為無，確保觸摸時響應迅速
    pagesContainer.style.transition = 'none';
  }, { passive: true });
  
  // 使用 EventManager 添加觸摸移動事件
  EventManager.add(pagesContainer, 'touchmove', function(e) {
    // 如果沒有啟動滑動或初始觸摸是在項目上，則不處理
    if (!startX || initialTarget.closest('.quick-other-item')) return;
    
    const currentX = e.touches[0].clientX;
    const currentY = e.touches[0].clientY;
    const diffX = startX - currentX;
    const diffY = startY - currentY;
    
    // 設置滑動標記，供其他事件參考
    if (Math.abs(diffX) > 5) {
      window.isSwiping = true;
    }
    
    // 判斷是否垂直滾動
    if (!isScrollingVertical && Math.abs(diffY) > Math.abs(diffX) * 1.2) {
      isScrollingVertical = true;
      return;
    }
    
    // 如果是垂直滾動，不處理水平滑動
    if (isScrollingVertical) return;
    
    // 防止事件冒泡，確保滑動時頁面不會跟著滾動
    e.preventDefault();
    
    // 計算偏移量
    const pageWidth = pagesContainer.offsetWidth;
    const movePercent = (diffX / pageWidth) * 100;
    const currentOffset = -currentSwipePage * 100;
    const newOffset = currentOffset - movePercent;
    
    // 應用新的位置，添加阻尼效果
    let finalOffset = newOffset;
    if (newOffset > 0) {
      finalOffset = newOffset * 0.3; // 左端阻尼
    } else if (newOffset < -(totalPages - 1) * 100) {
      const overScroll = newOffset + (totalPages - 1) * 100;
      finalOffset = -(totalPages - 1) * 100 + overScroll * 0.3; // 右端阻尼
    }
    
    pagesContainer.style.transform = `translateX(${finalOffset}%)`;
  }, { passive: false });
  
  // 使用 EventManager 添加觸摸結束事件
  EventManager.add(pagesContainer, 'touchend', function(e) {
    // 如果沒有啟動滑動或是垂直滾動，不處理
    if (!startX || isScrollingVertical || initialTarget.closest('.quick-other-item')) {
      startX = null;
      startY = null;
      initialTarget = null;
      return;
    }
    
    const currentX = e.changedTouches[0].clientX;
    const diffX = startX - currentX;
    const pageWidth = pagesContainer.offsetWidth;
    
    // 重置起始點
    startX = null;
    startY = null;
    initialTarget = null;
    
    // 恢復過渡效果
    pagesContainer.style.transition = 'transform 0.3s ease';
    
    // 判斷是否需要翻頁
    if (Math.abs(diffX) > pageWidth * 0.15) { // 只需15%的滑動距離
      if (diffX > 0 && currentSwipePage < totalPages - 1) {
        // 向左滑動 -> 下一頁
        updateSwipePageDisplay(currentSwipePage + 1);
      } else if (diffX < 0 && currentSwipePage > 0) {
        // 向右滑動 -> 上一頁
        updateSwipePageDisplay(currentSwipePage - 1);
      } else {
        // 邊界情況：回到當前頁
        updateSwipePageDisplay(currentSwipePage);
      }
    } else {
      // 滑動不夠遠，回到當前頁
      updateSwipePageDisplay(currentSwipePage);
    }
    
    // 延遲重置滑動標記
    setTimeout(() => {
      window.isSwiping = false;
    }, 100);
  }, { passive: true });
  
  // 設置分類標籤點擊事件
  const tabs = categoryNav.querySelectorAll('.category-tab');
  tabs.forEach((tab, index) => {
    // 清理舊事件並添加新事件
    EventManager.cleanElement(tab);
    EventManager.add(tab, 'click', function() {
      updateSwipePageDisplay(index);
    });
  });
}
// 車輛數據管理模塊，統一管理車輛數據，避免狀態不一致
const BusManager = {
  allDetectedBuses: [], // 全局車輛列表
  displayedBuses: [],   // 顯示的車輛列表
  editingBuses: [],     // 編輯中的車輛列表
  submittedBuses: [],   // 已提交的車輛列表
  activeEditingBusIndex: -1, // 當前編輯的車輛索引
  
  // 初始化模塊
  init: function() {
    // 從全局變量複製數據
    this.allDetectedBuses = [...allDetectedBuses];
    this.displayedBuses = [...displayedBuses];
    this.editingBuses = [...editingBuses];
    this.submittedBuses = [...submittedBuses];
    this.activeEditingBusIndex = activeEditingBusIndex;
    
    return this;
  },
  
  // 同步模塊數據到全局變量
  syncToGlobal: function() {
    allDetectedBuses = [...this.allDetectedBuses];
    displayedBuses = [...this.displayedBuses];
    editingBuses = [...this.editingBuses];
    submittedBuses = [...this.submittedBuses];
    activeEditingBusIndex = this.activeEditingBusIndex;
    
    return this;
  },
  
  // 添加新車輛，確保唯一ID和不重複
  addBus: function(bus) {
    if (!bus) return false;
    
    // 確保有唯一ID
    if (!bus.uniqueId) {
      bus.uniqueId = uuid.v4();
    }
    
    // 添加時間戳
    bus.lastUpdated = Date.now();
    
    // 檢查是否已存在相同ID的車輛
    const existInAll = this.allDetectedBuses.some(item => item.uniqueId === bus.uniqueId);
    
    if (!existInAll) {
      this.allDetectedBuses.push(bus);
    } else {
      // 如果已存在，更新而不是添加
      this.updateBus(bus.uniqueId, bus);
    }
    
    // 檢查是否應該添加到顯示列表
    const existInDisplay = this.displayedBuses.some(item => item.uniqueId === bus.uniqueId);
    
    if (!existInDisplay && !this.isRecentlySubmitted(bus.plateNumber)) {
      this.displayedBuses.push(bus);
    }
    
    // 同步到全局變量
    this.syncToGlobal();
    
    return true;
  },
  
  // 根據唯一ID更新車輛
  updateBus: function(uniqueId, updateData) {
    if (!uniqueId || !updateData) return false;
    
    let updated = false;
    
    // 更新全局列表
    const globalIndex = this.allDetectedBuses.findIndex(item => item.uniqueId === uniqueId);
    if (globalIndex !== -1) {
      this.allDetectedBuses[globalIndex] = {
        ...this.allDetectedBuses[globalIndex],
        ...updateData,
        lastUpdated: Date.now()
      };
      updated = true;
    }
    
    // 更新顯示列表
    const displayIndex = this.displayedBuses.findIndex(item => item.uniqueId === uniqueId);
    if (displayIndex !== -1) {
      this.displayedBuses[displayIndex] = {
        ...this.displayedBuses[displayIndex],
        ...updateData,
        lastUpdated: Date.now()
      };
      updated = true;
    }
    
    // 更新編輯列表
    const editIndex = this.editingBuses.findIndex(item => item.uniqueId === uniqueId);
    if (editIndex !== -1) {
      this.editingBuses[editIndex] = {
        ...this.editingBuses[editIndex],
        ...updateData,
        lastUpdated: Date.now()
      };
      
      // 如果更新的是當前編輯中的車輛，可能需要更新UI
      if (editIndex === this.activeEditingBusIndex) {
        // 這裡僅標記需要更新，實際UI更新在調用處處理
      }
      
      updated = true;
    }
    
    if (updated) {
      // 同步到全局變量
      this.syncToGlobal();
    }
    
    return updated;
  },
  
  // 添加車輛到編輯列表
  addToEditing: function(bus, originalIndex) {
    if (!bus) return false;
    
    // 確保有唯一ID
    if (!bus.uniqueId) {
      bus.uniqueId = uuid.v4();
    }
    
    // 檢查是否已在編輯列表中
    const existingIndex = this.editingBuses.findIndex(item => item.uniqueId === bus.uniqueId);
    
    if (existingIndex !== -1) {
      // 已在編輯列表中，更新索引並設置為活躍
      this.activeEditingBusIndex = existingIndex;
    } else {
      // 創建編輯副本
      const editCopy = JSON.parse(JSON.stringify(bus));
      editCopy.selectedOtherItems = editCopy.selectedOtherItems || [];
      editCopy.originalPlateNumber = bus.plateNumber;
      editCopy.originalIndex = originalIndex;
      
      // 添加到編輯列表
      this.editingBuses.push(editCopy);
      this.activeEditingBusIndex = this.editingBuses.length - 1;
      
      // 標記為編輯中
      this.markAsEditing(bus.uniqueId);
    }
    
    // 同步到全局變量
    this.syncToGlobal();
    
    return true;
  },
  
  // 標記車輛為編輯中
  markAsEditing: function(uniqueId) {
    // 更新全局列表和顯示列表中的編輯狀態
    this.allDetectedBuses.forEach(bus => {
      if (bus.uniqueId === uniqueId) {
        bus.isInEditing = true;
      }
    });
    
    this.displayedBuses.forEach(bus => {
      if (bus.uniqueId === uniqueId) {
        bus.isInEditing = true;
      }
    });
    
    // 同步到全局變量
    this.syncToGlobal();
  },
  
  // 從編輯列表移除車輛
  removeFromEditing: function(index) {
    if (index < 0 || index >= this.editingBuses.length) return false;
    
    // 保存要移除的車輛信息
    const removedBus = this.editingBuses[index];
    
    // 移除編輯標記
    if (removedBus && removedBus.uniqueId) {
      this.allDetectedBuses.forEach(bus => {
        if (bus.uniqueId === removedBus.uniqueId) {
          bus.isInEditing = false;
        }
      });
      
      this.displayedBuses.forEach(bus => {
        if (bus.uniqueId === removedBus.uniqueId) {
          bus.isInEditing = false;
        }
      });
    }
    
    // 從編輯列表移除
    this.editingBuses.splice(index, 1);
    
    // 調整活躍索引
    if (this.editingBuses.length === 0) {
      this.activeEditingBusIndex = -1;
    } else if (this.activeEditingBusIndex >= this.editingBuses.length) {
      this.activeEditingBusIndex = this.editingBuses.length - 1;
    } else if (this.activeEditingBusIndex === index) {
      this.activeEditingBusIndex = 0;
    }
    
    // 同步到全局變量
    this.syncToGlobal();
    
    return true;
  },
  
  // 檢查車輛是否最近已提交
  isRecentlySubmitted: function(plateNumber) {
    const submissionTime = localStorage.getItem(`submitted_${plateNumber}`);
    if (!submissionTime) return false;
    
    const SUBMISSION_EXPIRY_TIME_MS = 2 * 60 * 1000; // 2分鐘
    return (Date.now() - parseInt(submissionTime)) < SUBMISSION_EXPIRY_TIME_MS;
  },
  
  // 同步所有列表中的編輯狀態
  syncEditingStatus: function() {
    // 創建唯一ID集合
    const editingIds = new Set(this.editingBuses.map(bus => bus.uniqueId));
    
    // 更新顯示列表
    this.displayedBuses.forEach(bus => {
      bus.isInEditing = editingIds.has(bus.uniqueId);
    });
    
    // 更新全局列表
    this.allDetectedBuses.forEach(bus => {
      bus.isInEditing = editingIds.has(bus.uniqueId);
    });
    
    // 同步到全局變量
    this.syncToGlobal();
  },
  
  // 檢測和處理車牌重複問題
  detectAndResolveDuplicates: function() {
    // 檢查顯示列表中是否有車牌重複
    const plateMap = new Map();
    const duplicatePlates = new Set();
    
    // 第一遍掃描，找出重複車牌
    this.displayedBuses.forEach(bus => {
      if (plateMap.has(bus.plateNumber)) {
        duplicatePlates.add(bus.plateNumber);
      } else {
        plateMap.set(bus.plateNumber, bus);
      }
    });
    
    // 如果有重複車牌，進行處理
    if (duplicatePlates.size > 0) {
      console.log(`檢測到 ${duplicatePlates.size} 個重複車牌:`, Array.from(duplicatePlates));
      
      // 對每個重複車牌，保留最新更新的一個
      duplicatePlates.forEach(plateNumber => {
        // 收集所有該車牌的車輛
        const buses = this.displayedBuses.filter(bus => bus.plateNumber === plateNumber);
        
        // 按最後更新時間排序，保留最新的一個
        buses.sort((a, b) => (b.lastUpdated || 0) - (a.lastUpdated || 0));
        
        // 保留最新更新的車輛
        const keepBus = buses[0];
        
        // 從顯示列表和全局列表中移除其餘重複項
        for (let i = 1; i < buses.length; i++) {
          const removeBus = buses[i];
          
          this.displayedBuses = this.displayedBuses.filter(bus => bus.uniqueId !== removeBus.uniqueId);
          this.allDetectedBuses = this.allDetectedBuses.filter(bus => bus.uniqueId !== removeBus.uniqueId);
          
          console.log(`移除重複車牌 ${plateNumber} 的車輛, ID: ${removeBus.uniqueId}`);
        }
      });
      
      // 同步到全局變量
      this.syncToGlobal();
      
      return true;
    }
    
    return false;
  }
};
// 改進的位置獲取函數，提供更多的錯誤處理和位置源信息
async function getCurrentPosition(silent = false) {
  showLoading();
  console.log("開始獲取高精度位置...");
  
  let retryCount = 0;
  const maxRetries = 3;
  let locationSource = "即時GPS"; // 標記位置來源

  try {
    while (retryCount < maxRetries && navigator.geolocation) {
      try {
        // 清除之前的位置監視
        if (window.watchId) {
          navigator.geolocation.clearWatch(window.watchId);
          window.watchId = null;
        }
        
        const position = await new Promise((resolve, reject) => {
          navigator.geolocation.getCurrentPosition(resolve, reject, {
            enableHighAccuracy: true,
            timeout: 20000,
            maximumAge: 0
          });
        });

        console.log("高精度位置獲取成功");
        currentLatitude = position.coords.latitude;
        currentLongitude = position.coords.longitude;
        savePosition(currentLatitude, currentLongitude);
        
        // 更新位置精度指示器
        updateLocationAccuracyIndicator(position.coords.accuracy, locationSource);
        
        // 重新啟動位置監視
        startHighAccuracyLocationWatching(true);
        
        hideLoading();
        return {
          success: true,
          source: locationSource,
          accuracy: position.coords.accuracy
        };
      } catch (geoError) {
        console.error("位置API錯誤:", geoError.code, geoError.message);
        retryCount++;
        
        if (retryCount < maxRetries) {
          console.log(`位置獲取失敗，進行第${retryCount}次重試`);
          await new Promise(resolve => setTimeout(resolve, 3000));
        } else {
          console.log("達到最大重試次數");
          break;
        }
      }
    }

    // 嘗試使用本地緩存位置
    if (loadLastPosition()) {
      console.log("使用本地緩存位置作為後備");
      locationSource = "緩存位置";
      
      // 更新位置精度指示器
      updateLocationAccuracyIndicator(100, locationSource); // 假設緩存位置精度為100米
      
      hideLoading();
      return {
        success: true,
        source: locationSource,
        accuracy: 100 // 估計精度
      };
    }
    
    // 使用默認位置作為最後後備
    console.log("使用預設位置作為後備");
    locationSource = "預設位置";
    currentLatitude = 25.033; // 台北市中心位置
    currentLongitude = 121.565;
    savePosition(currentLatitude, currentLongitude);
    
    // 更新位置精度指示器為最低精度
    updateLocationAccuracyIndicator(999, locationSource);
    
    hideLoading();

    if (!silent) {
      showStatusMessage("無法準確獲取位置，使用預設位置", "warning", true);
    }
    return {
      success: true,
      source: locationSource,
      accuracy: 999
    };
  } catch (error) {
    console.error("位置獲取完全失敗:", error);
    hideLoading();
    
    // 更新位置精度指示器為出錯狀態
    updateLocationAccuracyIndicator(999, "錯誤");
    
    if (!silent) {
      showStatusMessage("無法獲取位置，請開啟位置權限或至室外", "error", true);
    }
    return {
      success: false,
      source: "錯誤",
      error: error.message
    };
  }
}
// 改進的位置精度指示器，顯示位置來源信息
function updateLocationAccuracyIndicator(accuracy, source = "GPS") {
  const accuracyElement = document.querySelector(".location-accuracy");
  if (!accuracyElement) return;
  
  if (accuracy === 999) {
    accuracyElement.innerHTML = `<i class="fas fa-exclamation-triangle" style="color:red;"></i> 無法獲取精確位置 (${source})`;
    return;
  }
  
  let color, text;
  if (accuracy < 10) {
    color = "green";
    text = "高";
  } else if (accuracy < 50) {
    color = "orange";
    text = "中";
  } else {
    color = "red";
    text = "低";
  }
  
  // 顯示位置來源
  const sourceText = source === "即時GPS" ? "" : ` - ${source}`;
  accuracyElement.innerHTML = `<i class="fas fa-crosshairs" style="color:${color};"></i> 位置精確度${text} (${Math.round(accuracy)}m${sourceText})`;
}

// 改進的車輛偵測函數，更好的錯誤處理和用戶反饋
async function detectBuses(isAutoDetection = false) {
  // 防止頻繁調用
  const now = Date.now();
  if (now - lastLoadingTime < MIN_LOADING_INTERVAL && isAutoDetection) {
    console.log("偵測請求過於頻繁，跳過本次自動偵測");
    return;
  }
  lastLoadingTime = now;
  
  // 顯示偵測指示器
  const indicatorMsg = isAutoDetection ? "自動偵測中..." : "正在偵測車輛...";
  showDetectionIndicator(indicatorMsg);
  
  // 使用性能監控
  PerformanceMonitor.start('detectBuses');
  
  try {
    // 獲取最新位置
    const positionResult = await forceUpdatePosition(isAutoDetection);
    if (!positionResult) {
      hideDetectionIndicator();
      if (!isAutoDetection) {
        showStatusMessage("無法獲取位置，偵測已取消", "error", true);
      }
      PerformanceMonitor.end('detectBuses');
      return;
    }

    // 保存當前編輯中的車輛的唯一ID和車牌號
    const editingBusIds = new Set(editingBuses.map(bus => bus.uniqueId));
    const editingPlateNumbers = new Set(editingBuses.map(bus => bus.plateNumber));

    // 清空全局列表，但保留編輯中的車輛
    allDetectedBuses = allDetectedBuses.filter(bus => 
      editingBusIds.has(bus.uniqueId) || editingPlateNumbers.has(bus.plateNumber)
    );
    
    displayedBuses = displayedBuses.filter(bus => 
      editingBusIds.has(bus.uniqueId) || editingPlateNumbers.has(bus.plateNumber)
    );

    // 獲取附近車輛
    const response = await fetchWithRetry(
      `${base_url}monitor/buses?latitude=${currentLatitude}&longitude=${currentLongitude}&distance=300`,
      {
        timeout: 15000 // 15秒超時
      },
      3
    );
    
    if (!response.ok) {
      throw new Error(`HTTP 錯誤 ${response.status}`);
    }
    
    const data = await response.json();
    const newDetectedBuses = [];
    
    // 用來追蹤已處理的車牌，避免重複
    const processedPlates = new Set();
    
    if (data && data.buses && data.buses.length > 0) {
      // 使用性能監控
      PerformanceMonitor.start('processBuses');
      
      // 優化處理大量車輛 - 先過濾出需要添加的車輛
      const busesToAdd = [];
      const busesToUpdate = [];
      
      data.buses.forEach((bus) => {
        // 如果車輛沒有唯一ID，生成一個
        if (!bus.uniqueId) {
          bus.uniqueId = uuid.v4();
        }
        
        // 新增檢查：車牌是否已經在本次處理中
        if (processedPlates.has(bus.plateNumber)) {
          console.log(`跳過本次偵測中重複的車牌: ${bus.plateNumber}`);
          return; // 跳過重複車牌
        }
        
        // 檢查此車牌是否在規定時間內已經提交過
        if (isRecentlySubmitted(bus.plateNumber)) {
          console.log(`跳過最近已提交的車輛: ${bus.plateNumber}`);
          return; // 跳過最近已提交的車輛
        }
        
        // 標記此車牌已處理
        processedPlates.add(bus.plateNumber);
        
        // 檢查這輛車是否已在編輯列表中(根據車牌號和唯一ID)
        const isInEditing = editingBusIds.has(bus.uniqueId) || editingPlateNumbers.has(bus.plateNumber);
        
        // 如果在編輯列表中，僅更新位置數據
        if (isInEditing) {
          // 找到對應的編輯中車輛
          let editingBusIndex = -1;
          
          // 先嘗試通過唯一ID找到
          editingBusIndex = editingBuses.findIndex(item => item.uniqueId === bus.uniqueId);
          
          // 如果通過ID沒找到，嘗試通過車牌號找到
          if (editingBusIndex === -1) {
            editingBusIndex = editingBuses.findIndex(item => item.plateNumber === bus.plateNumber);
          }
          
          if (editingBusIndex !== -1) {
            // 更新編輯中車輛的位置信息
            editingBuses[editingBusIndex].position = bus.position;
            // 確保唯一ID一致（如果通過車牌找到的）
            if (editingBuses[editingBusIndex].uniqueId !== bus.uniqueId) {
              bus.uniqueId = editingBuses[editingBusIndex].uniqueId;
            }
          }
          
          // 標記為已在編輯中
          bus.isInEditing = true;
          busesToUpdate.push(bus);
        } else if (isGroupCompany(bus.operatorName)) {
          // 檢查是否已存在相同車牌號的車輛（在全局列表中）
          const existingBusIndex = allDetectedBuses.findIndex(item => 
            item.plateNumber === bus.plateNumber);
          
          if (existingBusIndex === -1) {
            // 不存在，標記為新增
            bus.lastUpdated = Date.now(); // 添加最後更新時間戳
            busesToAdd.push(bus);
            
            // 只有不在編輯列表中的車輛才算作新偵測結果
            if (!isInEditing && !isRecentlySubmitted(bus.plateNumber)) {
              newDetectedBuses.push(bus);
            }
          } else {
            // 已存在，更新位置等信息
            bus.lastUpdated = Date.now();
            busesToUpdate.push(bus);
          }
        }
      });
      
      // 批量處理添加和更新
      if (busesToAdd.length > 0) {
        console.log(`新增 ${busesToAdd.length} 輛車輛`);
        allDetectedBuses.push(...busesToAdd);
        
        // 過濾出不在最近提交列表中的車輛添加到顯示列表
        const displayBusesToAdd = busesToAdd.filter(bus => 
          !isRecentlySubmitted(bus.plateNumber) && 
          !displayedBuses.some(item => item.plateNumber === bus.plateNumber)
        );
        
        if (displayBusesToAdd.length > 0) {
          displayedBuses.push(...displayBusesToAdd);
        }
      }
      
      // 批量更新已存在的車輛
      if (busesToUpdate.length > 0) {
        console.log(`更新 ${busesToUpdate.length} 輛車輛`);
        busesToUpdate.forEach(updateBus => {
          // 更新全局列表中的車輛
          const globalIndex = allDetectedBuses.findIndex(item => 
            item.plateNumber === updateBus.plateNumber || item.uniqueId === updateBus.uniqueId);
          
          if (globalIndex !== -1) {
            allDetectedBuses[globalIndex] = {
              ...allDetectedBuses[globalIndex],
              position: updateBus.position,
              lastUpdated: Date.now(),
              isInEditing: updateBus.isInEditing || allDetectedBuses[globalIndex].isInEditing
            };
          }
          
          // 更新顯示列表中的車輛
          const displayIndex = displayedBuses.findIndex(item => 
            item.plateNumber === updateBus.plateNumber || item.uniqueId === updateBus.uniqueId);
          
          if (displayIndex !== -1) {
            displayedBuses[displayIndex] = {
              ...displayedBuses[displayIndex],
              position: updateBus.position,
              lastUpdated: Date.now(),
              isInEditing: updateBus.isInEditing || displayedBuses[displayIndex].isInEditing
            };
          }
        });
      }
      
      PerformanceMonitor.end('processBuses');
    }
    
    // 確保所有編輯中的車輛都在顯示列表中
    editingBuses.forEach(editingBus => {
      // 檢查這輛車是否已經在顯示列表中(使用車牌和唯一ID檢查)
      const displayIndex = displayedBuses.findIndex(item => 
        item.uniqueId === editingBus.uniqueId || item.plateNumber === editingBus.plateNumber
      );
      
      // 如果不在顯示列表中，添加進去
      if (displayIndex === -1) {
        // 標記為已在編輯中
        editingBus.isInEditing = true;
        
        // 添加到顯示列表
        displayedBuses.push(editingBus);
        
        // 如果也不在全局列表中，添加進去
        const globalIndex = allDetectedBuses.findIndex(item => 
          item.uniqueId === editingBus.uniqueId || item.plateNumber === editingBus.plateNumber
        );
        if (globalIndex === -1) {
          allDetectedBuses.push(editingBus);
        }
      } else {
        // 確保顯示列表中的車輛標記為編輯中
        displayedBuses[displayIndex].isInEditing = true;
      }
    });
    
    // 檢測和處理車牌重複問題
    detectAndResolvePlateDuplicates();
    
    // 再次過濾最近提交的車輛
    filterRecentlySubmittedBuses();
    
    // 更新UI
    updateDetectedBusesList();
    
    // 顯示通知
    if (newDetectedBuses.length > 0) {
      showNewDetectionNotification(newDetectedBuses.length);
    } else if (!isAutoDetection) {
      showZeroDetectionNotification();
    }
    
    hideDetectionIndicator();
    PerformanceMonitor.end('detectBuses');
    
    if (!isAutoDetection) {
      PerformanceMonitor.printReport(); // 在非自動偵測時輸出性能報告
    }
  } catch (error) {
    console.error("偵測車輛失敗:", error);
    hideDetectionIndicator();
    
    if (!isAutoDetection) {
      showStatusMessage(`偵測車輛失敗: ${error.message || "未知錯誤"}，請稍後再試`, "error", true);
    }
    
    PerformanceMonitor.end('detectBuses');
  }
  
  if (!isAutoDetection) {
    logVehicleState("偵測車輛完成");
  }
  
  // 同步編輯狀態
  syncEditingStatus();
}
// 強制更新位置函數，更好的錯誤處理和位置回退機制
async function forceUpdatePosition(silent = false) {
  console.log("強制更新位置...");
  
  try {
    // 清除之前的位置監視，避免衝突
    if (window.watchId) {
      navigator.geolocation.clearWatch(window.watchId);
      window.watchId = null;
    }
    
    // 直接向瀏覽器請求高精度位置
    const position = await new Promise((resolve, reject) => {
      const timeoutId = setTimeout(() => {
        reject(new Error("獲取位置超時"));
      }, 15000); // 15秒超時
      
      navigator.geolocation.getCurrentPosition(
        (pos) => {
          clearTimeout(timeoutId);
          resolve(pos);
        }, 
        (err) => {
          clearTimeout(timeoutId);
          reject(err);
        }, 
        {
          enableHighAccuracy: true,
          timeout: 15000,
          maximumAge: 0
        }
      );
    });
    
    console.log("成功獲取新位置");
    currentLatitude = position.coords.latitude;
    currentLongitude = position.coords.longitude;
    savePosition(currentLatitude, currentLongitude);
    
    // 更新位置精度指示器
    updateLocationAccuracyIndicator(position.coords.accuracy, "即時GPS");
    
    // 重新啟動位置監視
    startHighAccuracyLocationWatching(true);
    
    return true;
  } catch (error) {
    console.error("強制更新位置失敗:", error);
    
    // 嘗試使用本地緩存作為後備
    if (loadLastPosition()) {
      // 只使用最近10秒內的緩存位置
      if (Date.now() - safeStorage.get("lastPositionTimestamp") < 10000) {
        if (!silent) {
          showStatusMessage("使用最近位置作為後備", "info", true);
        }
        
        // 更新位置精度指示器，使用較低的精度值表示這是緩存位置
        updateLocationAccuracyIndicator(100, "緩存位置");
        
        return true;
      }
    }
    
    if (!silent) {
      showStatusMessage("無法獲取位置，請確認位置權限並在室外使用", "error", true);
    }
    
    // 更新位置精度指示器為錯誤狀態
    updateLocationAccuracyIndicator(999, "錯誤");
    
    return false;
  }
}
// 使用DocumentFragment優化更新車輛列表
// 修改為使用 DocumentFragment 優化 DOM 操作
function updateDetectedBusesList() {
  // 獲取容器元素
  const container = document.getElementById("detectedBusesList");
  if (!container) return;
  
  // 記錄函數開始時間，用於性能測量
  const startTime = performance.now();
  
  // 更新計數
  const busCountElement = document.getElementById("busCount");
  if (busCountElement) {
    busCountElement.textContent = `${displayedBuses.length} 輛`;
  }
  
  // 使用 DocumentFragment 減少 DOM 操作次數
  const fragment = document.createDocumentFragment();
  
  if (displayedBuses.length === 0) {
    // 沒有車輛時顯示提示信息
    const noDataMessage = document.createElement("div");
    noDataMessage.className = "no-buses-message";
    noDataMessage.innerHTML = `
      <i class="fas fa-bus" style="font-size: 24px; color: #adb5bd; margin-bottom: 10px;"></i>
      <p>尚未檢測到車輛，請點擊「偵測車輛」按鈕</p>
    `;
    fragment.appendChild(noDataMessage);
  } else {
    // 創建新的車輛列表容器
    const busListContainer = document.createElement("div");
    busListContainer.className = "simple-bus-list";
    
    // 收集已在編輯中的車輛 ID，避免重複查詢
    const editingBusIds = new Set(editingBuses.map(bus => bus.uniqueId));
    
    // 使用虛擬列表技術處理顯示 - 首先只渲染可見的元素
    const batchSize = 20;
    const firstBatchEnd = Math.min(batchSize, displayedBuses.length);
    
    // 使用 WeakMap 緩存車輛距離計算結果，避免重複計算
    const distanceCache = new WeakMap();
    
    // 先渲染第一批可見的車輛
    for (let i = 0; i < firstBatchEnd; i++) {
      const bus = displayedBuses[i];
      
      // 緩存車輛是否在編輯中的狀態
      bus.isEditing = editingBusIds.has(bus.uniqueId);
      
      // 緩存車輛距離計算
      if (!distanceCache.has(bus)) {
        distanceCache.set(bus, getVehicleDistance(bus));
      }
      
      const busItem = createBusListItem(bus, i, distanceCache.get(bus));
      busListContainer.appendChild(busItem);
    }
    
    // 如果有更多車輛，使用 requestIdleCallback 或 setTimeout 延遲加載
    if (displayedBuses.length > batchSize) {
      const loadRemainingItems = () => {
        // 分批次加載剩餘車輛，每次加載一小批
        const startIdx = firstBatchEnd;
        const endIdx = displayedBuses.length;
        let currentIdx = startIdx;
        
        const loadNextBatch = () => {
          if (currentIdx >= endIdx) {
            // 所有批次加載完成，初始化跑馬燈
            setTimeout(debouncedInitMarquees, 100);
            return;
          }
          
          // 加載下一批
          const batchEndIdx = Math.min(currentIdx + batchSize, endIdx);
          
          // 使用 DocumentFragment 批量添加元素
          const batchFragment = document.createDocumentFragment();
          
          for (let i = currentIdx; i < batchEndIdx; i++) {
            const bus = displayedBuses[i];
            bus.isEditing = editingBusIds.has(bus.uniqueId);
            
            // 使用緩存的距離
            if (!distanceCache.has(bus)) {
              distanceCache.set(bus, getVehicleDistance(bus));
            }
            
            const busItem = createBusListItem(bus, i, distanceCache.get(bus));
            batchFragment.appendChild(busItem);
          }
          
          // 一次性添加到DOM
          busListContainer.appendChild(batchFragment);
          
          // 更新索引
          currentIdx = batchEndIdx;
          
          // 如果瀏覽器支持 requestIdleCallback，使用它來調度下一批加載
          if (window.requestIdleCallback) {
            window.requestIdleCallback(loadNextBatch);
          } else {
            setTimeout(loadNextBatch, 50);
          }
        };
        
        // 開始加載第一批
        if (window.requestIdleCallback) {
          window.requestIdleCallback(loadNextBatch);
        } else {
          setTimeout(loadNextBatch, 50);
        }
      };
      
      // 延遲加載剩餘項目
      setTimeout(loadRemainingItems, 100);
    } else {
      // 如果車輛數量少，直接初始化跑馬燈
      setTimeout(debouncedInitMarquees, 100);
    }
    
    fragment.appendChild(busListContainer);
  }
  
  // 檢測是否真的需要更新 DOM
  // 比較新舊內容的車輛數量，只有在不同時才更新
  const oldBusCount = container.querySelectorAll('.simple-bus-item').length;
  const newBusCount = displayedBuses.length;
  
  // 只有在車輛數量變化或強制更新時才替換整個內容
  if (oldBusCount !== newBusCount || container.querySelector('.no-buses-message')) {
    // 清空容器並一次性添加所有新元素
    container.innerHTML = "";
    container.appendChild(fragment);
  }
  
  // 記錄函數執行時間
  const endTime = performance.now();
  console.log(`更新車輛列表耗時: ${(endTime - startTime).toFixed(2)}ms，共 ${displayedBuses.length} 輛車`);
  
  // 觸發事件，通知其他組件更新完成
  const updateEvent = new CustomEvent('busListUpdated', { 
    detail: { count: displayedBuses.length } 
  });
  document.dispatchEvent(updateEvent);
  
  // 同步編輯狀態
  syncEditingStatus();
}
// 改進的車輛列表項創建函數，支持緩存距離和優化性能
function createBusListItem(bus, index, cachedDistance = null) {
  // 確保車輛有唯一ID和索引信息
  if (!bus.uniqueId) {
    bus.uniqueId = uuid.v4();
    // 更新全局列表中的對應車輛ID
    const globalBus = allDetectedBuses.find(b => 
      b.plateNumber === bus.plateNumber && 
      b.operatorName === bus.operatorName && 
      !b.uniqueId
    );
    if (globalBus) {
      globalBus.uniqueId = bus.uniqueId;
    }
  }
    
  // 存儲原始索引用於後續更新
  bus.originalIndex = index;
  
  // 使用 DocumentFragment 優化多元素添加
  const fragment = document.createDocumentFragment();
  
  // 創建主容器
  const busItem = document.createElement("div");
  busItem.className = "simple-bus-item";
  busItem.dataset.index = index;
  busItem.dataset.id = bus.uniqueId;

  // 修改編輯狀態判斷，只使用唯一ID精確匹配
  const isEditing = bus.isInEditing || editingBuses.some(editingBus => 
    editingBus.uniqueId === bus.uniqueId
  );
  
  if (isEditing) {
    busItem.classList.add("selected-bus-item");
  }
  
  // 路線信息
  const routeInfo = bus.routeName?.chinese || "未知路線";
  
  // 創建路線元素包裹容器
  const routeElement = document.createElement("div");
  routeElement.className = "bus-route-container";
  
  // 使用跑馬燈包裝路線文字
  const routeTextElement = document.createElement("div");
  routeTextElement.className = "text-marquee";
  
  // 如果中文字符數量超過5個，或總長度超過12個字符，則啟用跑馬燈
  const isChinese = countChineseChars(routeInfo) > 5;
  const isLong = routeInfo.length > 12;
  
  if (isChinese || isLong) {
    routeTextElement.classList.add("list-marquee", "scrolling");
    // 重複文本以避免空白間隔，使用「　」（全角空格）作為分隔
    const repeatedText = routeInfo + "　" + routeInfo;
    routeTextElement.textContent = repeatedText;
    // 設置動畫持續時間 - 緩存計算結果
    const duration = Math.min(20, Math.max(10, routeInfo.length * 0.7));
    routeTextElement.style.setProperty('--scroll-duration', `${duration}s`);
  } else {
    // 短路線名稱直接顯示，不使用跑馬燈
    routeTextElement.textContent = routeInfo;
  }
  
  // 添加title屬性，以便鼠標懸停時顯示完整路線
  routeElement.title = routeInfo;
  
  routeElement.appendChild(routeTextElement);
  
  // 創建車號元素
  const plateElement = document.createElement("div");
  plateElement.className = "bus-plate";
  
  // 獲取距離並設置對應的CSS類
  const distanceInMeters = cachedDistance !== null ? cachedDistance : getVehicleDistance(bus);
  
  // 使用函數添加對應的距離類
  addDistanceClassToElement(plateElement, distanceInMeters);
  
  // 添加方向樣式類
  if (bus.direction === "0") {
    plateElement.classList.add("direction-go");
  } else if (bus.direction === "1") {
    plateElement.classList.add("direction-back");
  }

  plateElement.textContent = bus.plateNumber;
  
  // 將元素添加到車輛項目中
  busItem.appendChild(routeElement);
  busItem.appendChild(plateElement);
  
  // 添加數據屬性，便於事件委托時識別
  busItem.dataset.plateNumber = bus.plateNumber;
  busItem.dataset.busIndex = index;
  
  return busItem;
}
// 改進的跑馬燈初始化函數，使用 IntersectionObserver 只處理可見元素
function initializeMarquees() {
  // 檢查是否已經初始化過 IntersectionObserver
  if (!window.marqueeObserver) {
    // 創建觀察器
    window.marqueeObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        const marquee = entry.target;
        
        // 只處理可見的元素
        if (entry.isIntersecting) {
          processMarquee(marquee);
        } else {
          // 不可見時暫停動畫
          marquee.classList.remove('scrolling');
        }
      });
    }, {
      root: null,
      rootMargin: '0px',
      threshold: 0.1 // 只需要10%可見即可觸發
    });
  }
  
  // 獲取所有需要處理的跑馬燈元素
  const marquees = document.querySelectorAll('.text-marquee');
  
  // 如果沒有元素，直接返回
  if (marquees.length === 0) return;
  
  // 添加所有元素到觀察器
  marquees.forEach(marquee => {
    // 先從觀察器中移除（避免重複添加）
    window.marqueeObserver.unobserve(marquee);
    
    // 重新添加到觀察器
    window.marqueeObserver.observe(marquee);
  });
}

// 處理單個跑馬燈元素
function processMarquee(marquee) {
  // 檢查元素是否可見且已渲染
  if (!isElementVisible(marquee)) return;
  
  // 獲取父元素和文本寬度
  const parentWidth = marquee.parentElement.offsetWidth;
  const textWidth = marquee.scrollWidth;
  
  // 只有當文本超出容器寬度時才設置滾動
  if (textWidth > parentWidth) {
    // 移除現有動畫類以重置
    marquee.classList.remove('scrolling');
    
    // 計算適當的動畫持續時間
    const textLength = marquee.textContent.length;
    const CHARACTER_SCROLL_SPEED = 0.7;
    const MIN_DURATION = 8;
    const MAX_DURATION = 20;
    
    let duration = textLength * CHARACTER_SCROLL_SPEED;
    duration = Math.max(MIN_DURATION, Math.min(MAX_DURATION, duration));
    
    // 設置動畫持續時間變量
    marquee.style.setProperty('--scroll-duration', `${duration}s`);
    
    // 強制重排
    void marquee.offsetWidth;
    
    // 重新添加動畫類
    marquee.classList.add('scrolling');
    
    // 特別處理列表跑馬燈
    if (marquee.classList.contains('list-marquee')) {
      // 優化列表項動畫速度
      let listDuration = duration * 0.7;
      marquee.style.setProperty('--scroll-duration', `${listDuration}s`);
    }
  } else {
    // 內容未超出，不需要滾動
    marquee.classList.remove('scrolling');
  }
}
// 使用事件委派替代多個個別事件，提高性能
function setupEventDelegation() {
  // 車輛列表的事件委派
  const busList = document.getElementById("detectedBusesList");
  
  // 移除現有事件監聽器（如果有）
  EventManager.cleanElement(busList);
  
  // 添加新的事件監聽器
  EventManager.add(busList, "click", function(e) {
    // 找到最近的 bus-item 元素
    const busItem = e.target.closest(".simple-bus-item");
    if (!busItem) return;
    
    const index = parseInt(busItem.dataset.index, 10);
    if (isNaN(index) || index < 0 || index >= displayedBuses.length) return;
    
    // 防止過快點擊
    if (busItem.dataset.processing === "true") return;
    busItem.dataset.processing = "true";
    
    // 使用防抖處理點擊
    setTimeout(() => {
      // 處理單擊事件
      selectBusForInput(displayedBuses[index], index, false);
      
      // 重置處理狀態
      setTimeout(() => {
        busItem.dataset.processing = "false";
      }, 300);
    }, 10);
  });
  
  // 為雙擊事件添加另一個監聽器
  EventManager.add(busList, "dblclick", function(e) {
    const busItem = e.target.closest(".simple-bus-item");
    if (!busItem) return;
    
    const index = parseInt(busItem.dataset.index, 10);
    if (isNaN(index) || index < 0 || index >= displayedBuses.length) return;
    
    // 雙擊時清除單擊的延遲處理
    clearTimeout(busItem._singleClickTimer);
    
    // 處理雙擊：添加到待編輯並滾動到編輯區
    selectBusForInput(displayedBuses[index], index, true);
  });
  
  // 主項目容器的事件委派
  const mainItemsContainer = document.getElementById("mainItemsContainer");
  if (mainItemsContainer) {
    EventManager.cleanElement(mainItemsContainer);
    EventManager.add(mainItemsContainer, "click", function(e) {
      const item = e.target.closest(".quick-item");
      if (!item) return;
      
      // 清除所有選中狀態
      mainItemsContainer.querySelectorAll(".quick-item").forEach(el => {
        el.classList.remove("selected");
      });
      
      // 設置當前項為選中
      item.classList.add("selected");
      
      // 儲存選擇到當前編輯的車輛對象
      if (activeEditingBusIndex >= 0 && activeEditingBusIndex < editingBuses.length) {
        editingBuses[activeEditingBusIndex].selectedMainItem = item.dataset.value;
        
        // 更新編輯界面以反映項目計數變化
        updateBusEditingInterface();
        updateEditingTabs();
      }
    });
  }
  
  // 添加更多需要的事件委派
  // ...
}
// 改進的網絡請求函數，支持重試、超時和更好的錯誤處理
async function fetchWithRetry(url, options = {}, retries = 3, delay = 1000) {
  // 添加請求超時功能
  let timeoutController;
  let timeoutId;
  
  // 如果瀏覽器支持 AbortController
  if (typeof AbortController !== 'undefined') {
    timeoutController = new AbortController();
    const timeoutMs = options.timeout || 15000; // 默認15秒超時
    
    // 設置超時取消
    timeoutId = setTimeout(() => {
      timeoutController.abort();
    }, timeoutMs);
    
    // 合併原有的 signal 和新建的 signal
    if (options.signal) {
      const originalSignal = options.signal;
      const abort = () => timeoutController.abort();
      originalSignal.addEventListener('abort', abort);
      
      // 清理函數
      const cleanup = () => originalSignal.removeEventListener('abort', abort);
      
      timeoutController.signal.addEventListener('abort', cleanup);
    }
    
    // 將 signal 添加到 options
    options = {
      ...options,
      signal: timeoutController.signal
    };
  }
  
  try {
    // 增加請求開始日誌
    console.log(`發起請求: ${options.method || 'GET'} ${url}`);
    const startTime = performance.now();
    
    const response = await fetch(url, options);
    
    // 記錄請求完成時間
    const duration = performance.now() - startTime;
    console.log(`請求完成: ${url}, 狀態: ${response.status}, 耗時: ${duration.toFixed(2)}ms`);
    
    // 清除超時
    if (timeoutId) clearTimeout(timeoutId);
    
    // 如果響應成功直接返回
    if (response.ok) return response;
    
    // 如果是401錯誤，可能是身份驗證問題
    if (response.status === 401) {
      showStatusMessage("身份驗證失敗，請重新登錄", "error", true);
      throw new Error(`身份驗證錯誤: ${response.status}`);
    }
    
    // 如果是5xx服務器錯誤且還有重試次數，則重試
    if (response.status >= 500 && retries > 1) {
      console.log(`服務器錯誤 ${response.status}，${retries-1}次重試剩餘，等待${delay}ms...`);
      await new Promise(resolve => setTimeout(resolve, delay));
      return fetchWithRetry(url, options, retries - 1, delay * 1.5);
    }
    
    // 其他錯誤，嘗試獲取詳細錯誤信息
    let errorMessage;
    try {
      const errorData = await response.json();
      errorMessage = errorData.message || errorData.error || `HTTP錯誤 ${response.status}`;
    } catch (e) {
      errorMessage = `HTTP錯誤 ${response.status}`;
    }
    
    throw new Error(errorMessage);
  } catch (err) {
    // 清除超時
    if (timeoutId) clearTimeout(timeoutId);
    
    // 處理中斷錯誤
    if (err.name === 'AbortError') {
      throw new Error('請求超時，請檢查網絡連接');
    }
    
    // 處理網絡錯誤
    if (err.message.includes('Network') && retries > 1) {
      console.log(`網絡錯誤，${retries-1}次重試剩餘，等待${delay}ms...`, err);
      await new Promise(resolve => setTimeout(resolve, delay));
      return fetchWithRetry(url, options, retries - 1, delay * 1.5);
    }
    
    // 無法進一步重試
    if (retries <= 1) {
      // 提供更友好的錯誤信息
      let userMessage;
      if (err.message.includes('Network')) {
        userMessage = '網絡連接錯誤，請檢查網絡後重試';
      } else if (err.message.includes('timeout')) {
        userMessage = '請求超時，服務器響應過慢';
      } else {
        userMessage = `請求錯誤: ${err.message}`;
      }
      
      console.error(userMessage, err);
      throw new Error(userMessage);
    }
    
    // 繼續重試
    await new Promise(resolve => setTimeout(resolve, delay));
    return fetchWithRetry(url, options, retries - 1, delay * 1.5);
  }
}
// 改進的選擇車輛函數，更好地處理狀態同步和索引管理
function selectBusForInput(bus, index, scrollToView = false) {
  logVehicleState(`開始選擇車輛-${bus.plateNumber}`);
  
  // 防止重複選擇正在處理中的車輛
  if (isProcessingBus && bus.uniqueId && editingBuses.some(editBus => editBus.uniqueId === bus.uniqueId)) {
    console.log(`車輛 ${bus.plateNumber} 已在編輯中，直接滾動到編輯區域`);
    
    // 找到編輯中的索引
    const editIndex = editingBuses.findIndex(editBus => editBus.uniqueId === bus.uniqueId);
    if (editIndex !== -1) {
      activeEditingBusIndex = editIndex;
      // 更新編輯界面和標籤
      updateEditingTabs();
      updateBusEditingInterface();
    }
    
    if (scrollToView) {
      scrollToEditingArea();
    }
    return;
  }
  
  // 確保有唯一ID，如果沒有則創建
  if (!bus.uniqueId) {
    bus.uniqueId = uuid.v4();
    
    // 檢查索引有效性
    if (index !== undefined && index >= 0 && index < displayedBuses.length) {
      displayedBuses[index].uniqueId = bus.uniqueId;
    }
    
    // 嘗試在全局列表中找到對應車輛並同步ID
    const globalIndex = allDetectedBuses.findIndex(item => 
      item.plateNumber === bus.plateNumber && 
      item.operatorName === bus.operatorName
    );
    
    if (globalIndex !== -1) {
      allDetectedBuses[globalIndex].uniqueId = bus.uniqueId;
    }
    
    console.log(`創建新唯一ID: ${bus.uniqueId}`);
  }
  
  // 明確記錄這台車輛在顯示列表中的索引
  const originalIndex = index;
  
  // 查找是否已在編輯列表中 - 使用唯一ID精確匹配
  let existingIndex = editingBuses.findIndex(item => item.uniqueId === bus.uniqueId);
  
  let busToEdit;
  if (existingIndex !== -1) {
    // 已存在於編輯列表，切換到該編輯視圖
    activeEditingBusIndex = existingIndex;
    busToEdit = editingBuses[existingIndex];
    
    // 確保記錄原始索引
    busToEdit.originalIndex = originalIndex;
    
    console.log(`找到已編輯車輛，索引: ${existingIndex}, ID: ${busToEdit.uniqueId}`);
  } else {
    // 創建新的編輯項
    busToEdit = JSON.parse(JSON.stringify(bus)); // 深拷貝
    busToEdit.selectedOtherItems = busToEdit.selectedOtherItems || [];
    busToEdit.originalPlateNumber = bus.plateNumber;
    
    // 明確記錄原始顯示列表索引
    busToEdit.originalIndex = originalIndex;
    
    console.log(`創建新編輯車輛，原始索引: ${originalIndex}, ID: ${busToEdit.uniqueId}`);
    
    // 標記基礎資料來源列表中的車輛為正在編輯
    if (displayedBuses[originalIndex] && displayedBuses[originalIndex].uniqueId === bus.uniqueId) {
      displayedBuses[originalIndex].isInEditing = true;
    }
    
    // 查找並標記全局列表中的對應車輛
    if (bus.uniqueId) {
      const globalBus = allDetectedBuses.find(item => item.uniqueId === bus.uniqueId);
      if (globalBus) {
        globalBus.isInEditing = true;
      }
    }
    
    editingBuses.push(busToEdit);
    activeEditingBusIndex = editingBuses.length - 1;
  }
  
  // 設置處理狀態
  isProcessingBus = true;
  
  // 更新介面
  updateBusEditingInterface();
  document.getElementById("busInputContainer").classList.remove("hidden");
  updateBusSelectionInList();
  
  if (scrollToView) {
    scrollToEditingArea();
  }
  
  // 同步編輯狀態
  syncEditingStatus();
  
  // 重置提交按鈕狀態
  resetSubmitButtonState();
}
// 改進的記錄提交函數，更好地處理項目分類和錯誤處理
async function submitBusRecord(bus, index, mainItem, selectedOtherItems) {
  showLoading();
  
  try {
    // 確保有選擇主要項目
    if (!mainItem) {
      showStatusMessage("請選擇查核結果", "error");
      hideLoading();
      return Promise.reject(new Error("未選擇查核結果"));
    }
    
    // 確保 selectedOtherItems 是數組
    let itemsArray = [];
    
    if (Array.isArray(selectedOtherItems)) {
      itemsArray = [...selectedOtherItems]; // 建立副本
    } else if (typeof selectedOtherItems === 'string') {
      // 處理逗號分隔的字符串
      itemsArray = selectedOtherItems.split(',')
        .map(item => item.trim())
        .filter(item => item.length > 0);
    } else if (selectedOtherItems && typeof selectedOtherItems === 'object') {
      // 處理對象形式
      try {
        itemsArray = Object.values(selectedOtherItems).filter(item => item);
      } catch (e) {
        console.error("解析selectedOtherItems對象失敗:", e);
        itemsArray = [];
      }
    }
    
    console.log("處理後的選中項目數組:", itemsArray);
    
    // 定義正向和負向項目數組
    const positiveItems = [];
    const negativeItems = [];
    const unclassifiedItems = [];
    
    // 使用 Map 緩存項目類型，避免重複查詢
    const itemTypeCache = new Map();
    
    // 遍歷所有選中的項目，進行分類
    for (let i = 0; i < itemsArray.length; i++) {
      const itemName = itemsArray[i];
      if (!itemName) continue; // 跳過空白項目
      
      // 檢查緩存中是否已有此項目類型
      if (itemTypeCache.has(itemName)) {
        const cachedType = itemTypeCache.get(itemName);
        
        if (cachedType === "positive") {
          positiveItems.push(itemName);
        } else if (cachedType === "negative") {
          negativeItems.push(itemName);
        } else {
          unclassifiedItems.push(itemName);
        }
        
        continue;
      }
      
      // 在 otherItems 中查找對應項目
      let foundItem = null;
      
      // 確保 otherItems 存在且是數組
      if (Array.isArray(otherItems) && otherItems.length > 0) {
        foundItem = otherItems.find(item => 
          item && item.itemName === itemName
        );
      }
      
      if (foundItem) {
        // 使用輔助函數檢查項目類型
        const itemType = logItemClassification(itemName, foundItem);
        
        // 緩存結果
        itemTypeCache.set(itemName, itemType);
        
        if (itemType === "positive") {
          console.log(`✅ 確認 "${itemName}" 為正向項目，加入 goodItem`);
          positiveItems.push(itemName);
        } else if (itemType === "negative") {
          console.log(`❌ 確認 "${itemName}" 為負向項目，加入 otherItem`);
          negativeItems.push(itemName);
        } else {
          console.log(`⚠️ 項目 "${itemName}" 類型無法確定，加入 otherItem`);
          unclassifiedItems.push(itemName);
        }
      } else {
        // 找不到對應項目的情況
        console.log(`⚠️ 無法在 otherItems 中找到項目 "${itemName}"，加入 otherItem`);
        unclassifiedItems.push(itemName);
        
        // 緩存結果
        itemTypeCache.set(itemName, null);
      }
    }
    
    // 將未分類項目加入負向項目列表
    const finalNegativeItems = [...negativeItems, ...unclassifiedItems];
    
    // 構建最終新增數據
    const submissionData = {
      userId: document.getElementById("userId").value,
      location: document.getElementById("location").value,
      plateNumbCompany: bus.operatorName || "不明",
      routeName: bus.routeName?.chinese || "不明",
      plateNumber: bus.plateNumber,
      direction: bus.direction || "0",
      positionLat: `(${bus.position?.latitude || currentLatitude},${
        bus.position?.longitude || currentLongitude
      })`,
      mainItem: mainItem,
      otherItem: finalNegativeItems.join(", "), // 負向項目和未分類項目
      goodItem: positiveItems.join(", ")        // 正向項目
    };
    
    // 詳細記錄最終新增的數據
    console.log("最終新增數據:", JSON.stringify(submissionData, null, 2));
    console.log("正向項目(goodItem):", positiveItems);
    console.log("負向項目(otherItem):", finalNegativeItems);
    
    // 發送請求
    const response = await fetchWithRetry(
      `${base_url}monitor/records`,
      {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(submissionData),
        timeout: 20000 // 20秒超時
      },
      3 // 3次重試
    );
    
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(errorText || `HTTP錯誤 ${response.status}`);
    }
    
    // 處理成功響應
    const data = await response.json();
    console.log("新增成功，服務器響應:", data);
    
    // 更新UI和本地存儲
    handleSubmitSuccess(bus);
    
    return Promise.resolve(data);
  } catch (error) {
    console.error("新增失敗:", error);
    showFloatingNotification(`新增失敗: ${error.message}`, "error");
    return Promise.reject(error);
  } finally {
    hideLoading();
  }
}
// 改進的同步編輯狀態函數，確保所有相關列表保持一致
function syncEditingStatus() {
  console.log("同步編輯狀態...");
  
  try {
    // 收集所有編輯中車輛的唯一ID和車牌號
    const editingIds = new Set(editingBuses.map(bus => bus.uniqueId));
    const editingPlates = new Set(editingBuses.map(bus => bus.plateNumber));
    
    let statusChanged = false;
    
    // 更新所有顯示列表中的編輯狀態
    displayedBuses.forEach(bus => {
      // 如果沒有唯一ID，嘗試為其分配一個
      if (!bus.uniqueId) {
        console.warn(`警告: 顯示列表中找到沒有唯一ID的車輛: ${bus.plateNumber}`);
        bus.uniqueId = uuid.v4();
        // 同步唯一ID到全局列表中對應的車輛
        const globalBus = allDetectedBuses.find(item => 
          item.plateNumber === bus.plateNumber && !item.uniqueId);
        if (globalBus) {
          globalBus.uniqueId = bus.uniqueId;
        }
      }
      
      // 檢查車輛是否應該處於編輯狀態
      const shouldBeEditing = editingIds.has(bus.uniqueId) || editingPlates.has(bus.plateNumber);
      
      // 如果狀態需要變更
      if (bus.isInEditing !== shouldBeEditing) {
        bus.isInEditing = shouldBeEditing;
        statusChanged = true;
        
        console.log(`車輛 ${bus.plateNumber} (ID: ${bus.uniqueId}) 編輯狀態變更為: ${shouldBeEditing}`);
        
        // 如果車輛應該處於編輯狀態但不在編輯列表中，檢查是否需要添加到編輯列表
        if (shouldBeEditing && !editingIds.has(bus.uniqueId)) {
          // 檢查是否因為車牌號匹配而應該編輯，但ID不匹配的情況
          if (editingPlates.has(bus.plateNumber)) {
            // 查找對應的編輯中車輛
            const editingBus = editingBuses.find(item => item.plateNumber === bus.plateNumber);
            if (editingBus) {
              // 更新編輯中車輛的ID為當前車輛的ID
              editingBus.uniqueId = bus.uniqueId;
              console.log(`更新編輯中車輛 ${editingBus.plateNumber} 的ID為 ${bus.uniqueId}`);
            }
          }
        }
      }
    });
    
    // 更新全局列表中的編輯狀態
    allDetectedBuses.forEach(bus => {
      if (!bus.uniqueId) {
        console.warn(`警告: 全局列表中找到沒有唯一ID的車輛: ${bus.plateNumber}`);
        bus.uniqueId = uuid.v4();
      }
      
      const shouldBeEditing = editingIds.has(bus.uniqueId) || editingPlates.has(bus.plateNumber);
      if (bus.isInEditing !== shouldBeEditing) {
        bus.isInEditing = shouldBeEditing;
        statusChanged = true;
      }
    });
    
    // 確保編輯列表中的車輛有正確的isInEditing標記
    editingBuses.forEach(bus => {
      if (!bus.isInEditing) {
        bus.isInEditing = true;
        statusChanged = true;
      }
    });
    
    // 如果有狀態變更，更新UI
    if (statusChanged) {
      updateBusSelectionInList();
    }
    
    return true;
  } catch (error) {
    console.error("同步編輯狀態時發生錯誤:", error);
    return false;
  }
}
// 改進的浮動通知系統，支持隊列和多種通知類型
const NotificationSystem = {
  queue: [],
  isShowing: false,
  notificationElement: null,
  
  // 初始化通知系統
  init: function() {
    // 檢查通知元素是否存在
    this.notificationElement = document.getElementById("floatingNotification");
    
    // 如果不存在，創建一個
    if (!this.notificationElement) {
      this.notificationElement = document.createElement("div");
      this.notificationElement.id = "floatingNotification";
      this.notificationElement.className = "floating-notification";
      document.body.appendChild(this.notificationElement);
    }
    
    return this;
  },
  
  // 顯示通知
  show: function(message, type = "info", duration = 4000) {
    // 確保初始化
    this.init();
    
    // 添加到隊列
    this.queue.push({
      message,
      type,
      duration
    });
    
    // 如果當前沒有顯示通知，開始顯示
    if (!this.isShowing) {
      this.processQueue();
    }
    
    return this;
  },
  
  // 處理通知隊列
  processQueue: function() {
    if (this.queue.length === 0) {
      this.isShowing = false;
      return;
    }
    
    // 取出下一個通知
    const notification = this.queue.shift();
    this.isShowing = true;
    
    // 設置通知內容和樣式
    this.notificationElement.textContent = notification.message;
    this.notificationElement.className = "floating-notification"; // 重置類
    this.notificationElement.classList.add(notification.type);
    
    // 顯示通知
    this.notificationElement.classList.add("show");
    
    // 設置自動隱藏
    setTimeout(() => {
      this.notificationElement.classList.remove("show");
      
      // 等待動畫完成後處理下一個通知
      setTimeout(() => {
        this.processQueue();
      }, 300);
    }, notification.duration);
  },
  
  // 快捷方法
  success: function(message, duration = 4000) {
    return this.show(message, "success", duration);
  },
  
  error: function(message, duration = 5000) {
    return this.show(message, "error", duration);
  },
  
  info: function(message, duration = 4000) {
    return this.show(message, "info", duration);
  },
  
  warning: function(message, duration = 4500) {
    return this.show(message, "warning", duration);
  }
};

// 替代原有的 showFloatingNotification 函數
function showFloatingNotification(message, type, duration) {
  NotificationSystem.show(message, type, duration);
}
// 性能監控和日誌系統，幫助診斷問題
const PerformanceMonitor = {
  metrics: {},
  startTimes: {},
  
  // 開始測量
  start: function(name) {
    this.startTimes[name] = performance.now();
    return this;
  },
  
  // 結束測量
  end: function(name) {
    if (!this.startTimes[name]) {
      console.warn(`未找到 ${name} 的開始時間`);
      return this;
    }
    
    const duration = performance.now() - this.startTimes[name];
    
    // 保存測量結果
    if (!this.metrics[name]) {
      this.metrics[name] = {
        count: 0,
        totalDuration: 0,
        minDuration: duration,
        maxDuration: duration
      };
    }
    
    const metric = this.metrics[name];
    metric.count++;
    metric.totalDuration += duration;
    metric.minDuration = Math.min(metric.minDuration, duration);
    metric.maxDuration = Math.max(metric.maxDuration, duration);
    
    // 輸出詳細日誌，只在開發環境
    if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
      console.log(`${name} 耗時: ${duration.toFixed(2)}ms`);
    }
    
    delete this.startTimes[name];
    return this;
  },
  
  // 獲取指標報告
  getReport: function() {
    const report = {};
    
    Object.keys(this.metrics).forEach(name => {
      const metric = this.metrics[name];
      report[name] = {
        count: metric.count,
        avgDuration: metric.totalDuration / metric.count,
        minDuration: metric.minDuration,
        maxDuration: metric.maxDuration
      };
    });
    
    return report;
  },
  
  // 輸出報告到控制台
  printReport: function() {
    console.group('性能監控報告');
    
    const report = this.getReport();
    Object.keys(report).forEach(name => {
      const { count, avgDuration, minDuration, maxDuration } = report[name];
      console.log(`${name}: ${count}次調用, 平均${avgDuration.toFixed(2)}ms, 最小${minDuration.toFixed(2)}ms, 最大${maxDuration.toFixed(2)}ms`);
    });
    
    console.groupEnd();
    return this;
  },
  
  // 重置指標
  reset: function() {
    this.metrics = {};
    this.startTimes = {};
    return this;
  }
};

// 高級日誌系統
const Logger = {
  // 日誌級別
  LogLevel: {
    DEBUG: 0,
    INFO: 1,
    WARN: 2,
    ERROR: 3
  },
  
  currentLevel: 1, // 默認INFO級別
  
  // 設置日誌級別
  setLevel: function(level) {
    this.currentLevel = level;
    return this;
  },
  
  // 不同級別的日誌方法
  debug: function(...args) {
    if (this.currentLevel <= this.LogLevel.DEBUG) {
      console.debug('[DEBUG]', ...args);
    }
    return this;
  },
  
  info: function(...args) {
    if (this.currentLevel <= this.LogLevel.INFO) {
      console.info('[INFO]', ...args);
    }
    return this;
  },
  
  warn: function(...args) {
    if (this.currentLevel <= this.LogLevel.WARN) {
      console.warn('[WARN]', ...args);
    }
    return this;
  },
  
  error: function(...args) {
    if (this.currentLevel <= this.LogLevel.ERROR) {
      console.error('[ERROR]', ...args);
    }
    return this;
  },
  
  // 功能性日誌方法
  api: function(method, url, status, duration) {
    if (this.currentLevel <= this.LogLevel.INFO) {
      const statusColor = status >= 200 && status < 300 ? 'green' : 'red';
      console.log(
        `%c[API] %c${method} %c${url} %c${status} %c${duration.toFixed(2)}ms`,
        'color: gray',
        'color: blue',
        'color: black',
        `color: ${statusColor}`,
        'color: purple'
      );
    }
    return this;
  },
  
  performance: function(operation, duration) {
    if (this.currentLevel <= this.LogLevel.DEBUG) {
      console.log(
        `%c[PERF] %c${operation}: %c${duration.toFixed(2)}ms`,
        'color: gray',
        'color: black',
        'color: blue'
      );
    }
    return this;
  },
  
  // 車輛操作日誌
  vehicle: function(operation, plateNumber, details = {}) {
    if (this.currentLevel <= this.LogLevel.INFO) {
      console.log(
        `%c[車輛] %c${operation}: %c${plateNumber}`,
        'color: gray',
        'color: black',
        'color: blue',
        details
      );
    }
    return this;
  }
};
// 事件防抖與節流工具，用於優化頻繁觸發的事件
const EventOptimizer = {
  // 防抖函數：延遲執行函數，如果在延遲期間再次調用則重新計時
  debounce: function(func, wait = 300, immediate = false) {
    let timeout;
    
    return function(...args) {
      const context = this;
      
      const later = function() {
        timeout = null;
        if (!immediate) func.apply(context, args);
      };
      
      const callNow = immediate && !timeout;
      
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      
      if (callNow) func.apply(context, args);
    };
  },
  
  // 節流函數：限制函數在一定時間內只能執行一次
  throttle: function(func, limit = 300) {
    let inThrottle;
    let lastFunc;
    let lastRan;
    
    return function(...args) {
      const context = this;
      
      if (!inThrottle) {
        func.apply(context, args);
        lastRan = Date.now();
        inThrottle = true;
      } else {
        clearTimeout(lastFunc);
        
        lastFunc = setTimeout(function() {
          if (Date.now() - lastRan >= limit) {
            func.apply(context, args);
            lastRan = Date.now();
          }
        }, limit - (Date.now() - lastRan));
      }
    };
  },
  
  // 防彈函數：結合防抖和節流，保證最小執行間隔同時也會延遲執行
  bulletproof: function(func, wait = 300, limit = 1000) {
    let timeout;
    let lastRan = 0;
    
    return function(...args) {
      const context = this;
      
      clearTimeout(timeout);
      
      const now = Date.now();
      const timeSinceLastRun = now - lastRan;
      
      if (timeSinceLastRun > limit) {
        // 如果超過限制時間，立即執行
        lastRan = now;
        func.apply(context, args);
      } else {
        // 否則設置延遲執行
        timeout = setTimeout(function() {
          lastRan = Date.now();
          func.apply(context, args);
        }, wait);
      }
    };
  }
};
// 更新列表中車輛的選中狀態
function updateBusSelectionInList() {
  // 清除所有選中狀態
  document.querySelectorAll('.simple-bus-item').forEach(item => {
    item.classList.remove('selected-bus-item');
  });
  
  // 為所有正在編輯的車輛添加標記
  if (editingBuses.length > 0) {
    // 收集所有編輯中車輛的唯一ID
    const editingBusIds = editingBuses.map(bus => bus.uniqueId);
    
    // 找到對應的列表項並標記為正在編輯
    document.querySelectorAll('.simple-bus-item').forEach((item, itemIndex) => {
      if (itemIndex < displayedBuses.length) {
        const bus = displayedBuses[itemIndex];
        if (bus && bus.uniqueId && editingBusIds.includes(bus.uniqueId)) {
          item.classList.add('selected-bus-item');
        }
      }
    });
  }
  
  // 強制更新列表顯示
  setTimeout(() => {
    debouncedInitMarquees();
  }, 50);
}
// 檢查元素是否可見
function isElementVisible(element) {
  // 檢查元素是否存在且已渲染
  if (!element || element.offsetWidth === 0 || element.offsetHeight === 0) return false;
  
  // 檢查元素是否在視口內（可選，視需求而定）
  const rect = element.getBoundingClientRect();
  return (
    rect.top >= 0 &&
    rect.left >= 0 &&
    rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
    rect.right <= (window.innerWidth || document.documentElement.clientWidth)
  );
}

// 檢查項目分類
function logItemClassification(itemName, foundItem) {
  if (!foundItem) {
    console.log(`項目 "${itemName}" 在 otherItems 中未找到，無法確定類型`);
    return null;
  }
  
  // 明確輸出itemType值，確保檢查值的問題
  console.log(`項目: "${itemName}", itemType值: ${foundItem.itemType} (${typeof foundItem.itemType})`);
  
  // 嘗試強制轉換為數字，以防是字符串格式
  const itemTypeAsNumber = Number(foundItem.itemType);
  
  if (itemTypeAsNumber === 1) {
    return "positive";
  } else if (itemTypeAsNumber === -1) {
    return "negative";
  } else {
    console.log(`項目 "${itemName}" 的 itemType 值 ${foundItem.itemType} 不是 1 或 -1`);
    return null;
  }
}

// 提交成功後的處理
function handleSubmitSuccess(bus) {
  // 先保存當前編輯車輛的索引和唯一ID
  const currentEditingIndex = activeEditingBusIndex;
  const uniqueId = bus.uniqueId;
  
  // 清除頂部錯誤訊息
  const statusElement = document.getElementById("statusMessage");
  statusElement.textContent = "";
  statusElement.className = "status-message";
  
  // 添加到已新增列表
  submittedBuses.push(bus.plateNumber);
  
  // 設置新增時間，3分鐘內不再顯示
  const submissionTime = Date.now();
  localStorage.setItem(`submitted_${bus.plateNumber}`, submissionTime.toString());
  
  // 從顯示和全局列表中移除此車輛
  if (uniqueId) {
    displayedBuses = displayedBuses.filter(item => item.uniqueId !== uniqueId);
    allDetectedBuses = allDetectedBuses.filter(item => item.uniqueId !== uniqueId);
  } else {
    displayedBuses = displayedBuses.filter(item => item.plateNumber !== bus.plateNumber);
    allDetectedBuses = allDetectedBuses.filter(item => item.plateNumber !== bus.plateNumber);
  }
  
  // 從編輯列表中移除此車輛，並調整當前活躍索引
  let removedFromEditing = false;
  
  for (let i = 0; i < editingBuses.length; i++) {
    if (editingBuses[i].uniqueId === uniqueId) {
      // 移除找到的車輛
      editingBuses.splice(i, 1);
      removedFromEditing = true;
      
      // 調整當前活躍索引
      if (i === activeEditingBusIndex) {
        // 如果刪除的是當前正在編輯的車輛
        if (editingBuses.length > 0) {
          // 如果還有其他車輛，選擇第一台作為當前活躍車輛
          activeEditingBusIndex = 0;
        } else {
          // 如果沒有其他車輛，設置為-1
          activeEditingBusIndex = -1;
          isProcessingBus = false;
        }
      } else if (i < activeEditingBusIndex) {
        // 如果刪除的車輛在當前活躍車輛之前，當前索引需要減1
        activeEditingBusIndex--;
      }
      
      // 已找到並處理，可以跳出循環
      break;
    }
  }
  
  // 更新UI
  updateDetectedBusesList();
  
  // 更新編輯標籤和界面
  updateEditingTabs();
  
  // 根據當前編輯狀態決定是否顯示編輯區域
  if (editingBuses.length === 0) {
    document.getElementById("busInputContainer").classList.add("hidden");
    isProcessingBus = false;
  } else {
    // 確保更新編輯界面
    updateBusEditingInterface();
    document.getElementById("busInputContainer").classList.remove("hidden");
  }
  
  // 更新列表中的選中狀態
  updateBusSelectionInList();
  
  // 修改這行，添加詳細資訊到成功提示
  const routeName = bus.routeName?.chinese || "未知路線";
  const companyName = bus.operatorName || "未知公司";
  const successMessage = `已成功送出記錄：${bus.plateNumber} (${companyName} ${routeName})`;
  
  // 使用浮動通知顯示詳細資訊
  showFloatingNotification(successMessage, "success");
}

// 檢測和處理車牌重複問題
function detectAndResolvePlateDuplicates() {
  // 檢查顯示列表中是否有車牌重複
  const plateMap = new Map();
  const duplicatePlates = new Set();
  
  // 第一遍掃描，找出重複車牌
  displayedBuses.forEach(bus => {
    if (plateMap.has(bus.plateNumber)) {
      duplicatePlates.add(bus.plateNumber);
    } else {
      plateMap.set(bus.plateNumber, bus);
    }
  });
  
  // 如果有重複車牌，進行處理
  if (duplicatePlates.size > 0) {
    console.log(`檢測到 ${duplicatePlates.size} 個重複車牌:`, Array.from(duplicatePlates));
    
    // 對每個重複車牌，保留最新更新的一個
    duplicatePlates.forEach(plateNumber => {
      // 收集所有該車牌的車輛
      const buses = displayedBuses.filter(bus => bus.plateNumber === plateNumber);
      
      // 按最後更新時間排序，保留最新的一個
      buses.sort((a, b) => (b.lastUpdated || 0) - (a.lastUpdated || 0));
      
      // 保留最新更新的車輛
      const keepBus = buses[0];
      
      // 從顯示列表和全局列表中移除其餘重複項
      for (let i = 1; i < buses.length; i++) {
        const removeBus = buses[i];
        
        displayedBuses = displayedBuses.filter(bus => bus.uniqueId !== removeBus.uniqueId);
        allDetectedBuses = allDetectedBuses.filter(bus => bus.uniqueId !== removeBus.uniqueId);
        
        console.log(`移除重複車牌 ${plateNumber} 的車輛, ID: ${removeBus.uniqueId}`);
      }
    });
    
    return true;
  }
  
  return false;
}

// 檢查車輛是否在最近2分鐘內提交過
function isRecentlySubmitted(plateNumber) {
  const submissionTime = localStorage.getItem(`submitted_${plateNumber}`);
  if (!submissionTime) return false;
  
  const twoMinutes = 2 * 60 * 1000;
  return (Date.now() - parseInt(submissionTime)) < twoMinutes;
}

// 過濾最近提交的車輛
function filterRecentlySubmittedBuses() {
  const currentTime = Date.now();
  const SUBMISSION_EXPIRY_TIME_MS = 2 * 60 * 1000; // 2分鐘時間常數
  
  // 從顯示列表中過濾
  displayedBuses = displayedBuses.filter(bus => {
    // 如果正在編輯中，始終保留
    if (bus.isInEditing) return true;
    
    const submissionTime = localStorage.getItem(`submitted_${bus.plateNumber}`);
    // 如果沒有提交記錄或提交時間超過常數定義的時間，則保留
    return !submissionTime || (currentTime - parseInt(submissionTime)) >= SUBMISSION_EXPIRY_TIME_MS;
  });
  
  // 更新UI
  updateDetectedBusesList();
}

// 重置提交按鈕狀態
function resetSubmitButtonState() {
  const submitButton = document.querySelector(".action-button.submit-button");
  if (submitButton && submitButton.classList.contains("disabled")) {
    submitButton.classList.remove("disabled");
  }
}

// 滾動到編輯區域
function scrollToEditingArea() {
  setTimeout(() => {
    const editingArea = document.getElementById("busInputContainer");
    if (editingArea && !editingArea.classList.contains("hidden")) {
      editingArea.scrollIntoView({ behavior: "smooth", block: "center" });
    }
  }, 100); // 短暫延遲，確保DOM已更新
}

// 修改或新增updateSwipePageDisplay函數
function updateSwipePageDisplay(pageIndex) {
  if (pageIndex < 0 || pageIndex >= totalPages || !pagesContainer || !categoryNav) return;
  
  // 更新當前頁碼
  currentSwipePage = pageIndex;
  
  // 更新分類標籤選中狀態
  const tabs = categoryNav.querySelectorAll('.category-tab');
  tabs.forEach((tab, idx) => {
    if (idx === pageIndex) {
      tab.classList.add('active');
      tab.style.backgroundColor = '#06c755';
      tab.style.color = 'white';
    } else {
      tab.classList.remove('active');
      tab.style.backgroundColor = '#f8f9fa';
      tab.style.color = '#333';
    }
  });
  
  // 平滑滑動到對應頁面
  pagesContainer.style.transition = 'transform 0.3s ease';
  pagesContainer.style.transform = `translateX(-${pageIndex * 100}%)`;
}
// 獲取車輛距離的輔助函數
function getVehicleDistance(bus) {
  // 預設999米
  let distanceInMeters = 999;
  
  // 嘗試從Distance字段獲取距離（如果存在）
  if (bus.Distance !== undefined) {
    distanceInMeters = bus.Distance * 1000; // 公里轉公尺
  }
  // 如果沒有Distance字段，嘗試從位置計算距離
  else if (bus.position && bus.position.latitude && bus.position.longitude) {
    distanceInMeters = calculateDistance(
      currentLatitude, 
      currentLongitude, 
      bus.position.latitude, 
      bus.position.longitude
    );
  }
  // 如果是手動添加的車輛且沒有距離信息，默認設為10米（很近）
  if (bus.isManualInput && distanceInMeters === 999) {
    distanceInMeters = 10;
  }
  return distanceInMeters;
}
// 更新編輯標籤
function updateEditingTabs() {
  // 檢查標籤容器是否存在，如果不存在則創建
  let tabsContainer = document.querySelector(".editing-tabs-container");
  
  // 如果沒有編輯中的車輛，隱藏標籤容器
  if (editingBuses.length === 0) {
    if (tabsContainer) tabsContainer.style.display = "none";
    return;
  }
  
  // 如果有編輯中的車輛，但沒有標籤容器，創建它
  if (!tabsContainer) {
    tabsContainer = document.createElement("div");
    tabsContainer.className = "editing-tabs-container";
    
    // 插入到busInputContainer之前
    const inputContainer = document.getElementById("busInputContainer");
    inputContainer.parentNode.insertBefore(tabsContainer, inputContainer);
  }
  
  // 確保標籤容器可見
  tabsContainer.style.display = "flex";
  
  // 清空現有標籤
  tabsContainer.innerHTML = '';
  
  // 為每個編輯中的車輛創建標籤
  editingBuses.forEach((bus, index) => {
    const tab = document.createElement("div");
    tab.className = "editing-tab";
    if (index === activeEditingBusIndex) {
      tab.classList.add("active");
    }
    
    // 計算已選項目數量
    let selectedItemsCount = 0;
    if (bus.selectedMainItem) selectedItemsCount++;
    if (bus.selectedOtherItems && Array.isArray(bus.selectedOtherItems)) {
      selectedItemsCount += bus.selectedOtherItems.length;
    }
    
    // 設置標籤內容
    tab.innerHTML = `
      <span>${bus.plateNumber || ''}</span>
      <span class="tab-close" data-index="${index}">×</span>
    `;
    
    // 如果有選項，添加計數標記
    if (selectedItemsCount > 0) {
      const countSpan = document.createElement("span");
      countSpan.className = "tab-item-count";
      countSpan.textContent = selectedItemsCount;
      countSpan.style.cssText = `
        display: inline-block;
        background-color: ${index === activeEditingBusIndex ? 'rgba(255,255,255,0.3)' : '#06c755'};
        color: white;
        border-radius: 50%;
        width: 18px;
        height: 18px;
        font-size: 11px;
        line-height: 18px;
        text-align: center;
        margin-left: 5px;
        font-weight: bold;
      `;
      
      // 將計數標記插入到關閉按鈕之前
      const closeBtn = tab.querySelector(".tab-close");
      tab.insertBefore(countSpan, closeBtn);
    }
    
    // 設置點擊事件，使用全局函數
    tab.onclick = function(event) {
      if (!event.target.classList.contains('tab-close')) {
        switchToEditingTab(index);
      }
    };
    
    // 為關閉按鈕添加點擊事件
    const closeBtn = tab.querySelector(".tab-close");
    closeBtn.onclick = function(event) {
      event.stopPropagation();
      confirmCancelEditing(index);
    };
    
    tabsContainer.appendChild(tab);
  });
  
  // 確保滾動到活躍標籤
  if (editingBuses.length > 0) {
    setTimeout(() => {
      scrollToActiveTab();
    }, 10);
  }
}

// 切換到指定標籤
function switchToEditingTab(index) {
  // 防止過快點擊
  if (window._switchTabTimer) return;
  window._switchTabTimer = setTimeout(() => {
    window._switchTabTimer = null;
  }, 300);
  
  console.log("標籤點擊，切換到索引:", index);
  
  // 設置活躍索引
  activeEditingBusIndex = index;
  
  // 更新標籤樣式
  const tabs = document.querySelectorAll('.editing-tab');
  tabs.forEach((tab, i) => {
    tab.classList.toggle('active', i === index);
  });
  
  // 確保編輯區域可見
  document.getElementById("busInputContainer").classList.remove("hidden");
  
  // 更新編輯界面
  updateBusEditingInterface();
  
  // 滾動到編輯區域
  scrollToEditingArea();
  
  // 同步編輯狀態
  syncEditingStatus();
}

// 滾動到活躍標籤
function scrollToActiveTab() {
  setTimeout(() => {
    // 給DOM更新一點時間
    const tabsContainer = document.querySelector(".editing-tabs-container");
    if (!tabsContainer) return;
    
    const activeTab = tabsContainer.querySelector(".editing-tab.active");
    if (!activeTab) return;
    
    // 計算滾動位置
    const scrollLeft = activeTab.offsetLeft - tabsContainer.offsetLeft - (tabsContainer.clientWidth / 2) + (activeTab.offsetWidth / 2);
    
    // 平滑滾動到標籤位置
    tabsContainer.scrollTo({
      left: Math.max(0, scrollLeft),
      behavior: 'smooth'
    });
  }, 50);
}
// 更新車輛編輯界面
function updateBusEditingInterface() {
  if (activeEditingBusIndex < 0 || editingBuses.length === 0) {
    // 沒有活躍的編輯車輛，隱藏編輯區域
    document.getElementById("busInputContainer").classList.add("hidden");
    return;
  }
  
  // 獲取當前活躍的編輯車輛
  const bus = editingBuses[activeEditingBusIndex];
  
  if (!bus) {
    console.error("活躍索引無效，無法找到車輛:", activeEditingBusIndex);
    return;
  }
  
  // 更新編輯標籤列
  updateEditingTabs();
  
  // 更新編輯區域內容
  const inputContainer = document.getElementById("busInputContainer");
  
  // 更新車輛信息
  const routeInfo = bus.routeName?.chinese || "不明";
  const directionInfo = bus.direction === "0" ? "去" : bus.direction === "1" ? "返" : "";
  
  // 更新路線顯示
  const routeElement = document.getElementById("inputBusRoute");
  routeElement.innerHTML = `
  <div class="route-direction-container">
    <div class="text-marquee">${routeInfo}</div>
    <div class="direction-tag" style="background-color: ${bus.direction === "0" ? "#007bff" : bus.direction === "1" ? "#28a745" : "#666"}; color: white;">
      ${directionInfo}
    </div>
  </div>`;
  
  // 檢查路線長度，如果過長則啟用跑馬燈效果
  setTimeout(() => {
    const textElement = routeElement.querySelector('.text-marquee');
    if (textElement) {
      const parentWidth = textElement.parentElement.offsetWidth;
      const textWidth = textElement.scrollWidth;
      
      if (textWidth > parentWidth) {
        textElement.classList.add('scrolling');
      } else {
        textElement.classList.remove('scrolling');
      }
    }
  }, 20);

  // 更新公司信息
  document.getElementById("inputBusCompany").textContent = bus.operatorName || "未知公司";
  
  // 計算已選項目數量
  let selectedItemsCount = 0;
  if (bus.selectedMainItem) selectedItemsCount++;
  if (bus.selectedOtherItems && Array.isArray(bus.selectedOtherItems)) {
    selectedItemsCount += bus.selectedOtherItems.length;
  }
  
  // 更新車號顯示
  const inputBusNumberElement = document.getElementById("inputBusNumber");
  const numberContainer = inputBusNumberElement.parentNode;

  // 移除舊的計數標記（如果存在）
  const oldBadge = document.getElementById("editingItemCountBadge");
  if (oldBadge) oldBadge.remove();

  // 處理手動輸入車輛的特殊情況
  if (bus.isManualInput) {
    // 如果是手動新增的車輛，並且不是輸入框，則替換為輸入框
    if (inputBusNumberElement.tagName !== 'INPUT') {
      const inputBox = document.createElement('input');
      inputBox.type = 'text';
      inputBox.id = 'inputBusNumber';
      inputBox.value = bus.plateNumber || '';
      inputBox.style.width = '100px';
      inputBox.style.padding = '3px 6px';
      inputBox.style.border = '1px solid #ddd';
      inputBox.style.borderRadius = '4px';
      inputBox.style.fontWeight = 'bold';
      
      // 處理輸入事件
      inputBox.addEventListener('input', function() {
        // 轉換為大寫
        this.value = this.value.toUpperCase();
        
        // 格式化車牌號碼
        formatPlateNumber(this);
        
        // 獲取當前編輯的車輛
        const currentBus = editingBuses[activeEditingBusIndex];
        
        // 保存新車號
        currentBus.plateNumber = this.value;
        
        // 記錄重要信息便於調試
        console.log(`車號輸入變更: ${currentBus.plateNumber}`);
        
        // 更新車輛數據
        updateVehicleByUniqueId(currentBus);
      });
      
      // 添加失去焦點時的重複檢查
      inputBox.addEventListener('blur', function() {
        const currentBus = editingBuses[activeEditingBusIndex];
        const newPlateNumber = this.value;
        
        // 檢查是否與其他車輛重複 (排除當前車輛自身)
        const duplicateVehicle = allDetectedBuses.find(bus => 
          bus.plateNumber === newPlateNumber && bus.uniqueId !== currentBus.uniqueId
        );
        
        if (duplicateVehicle) {
          showFloatingNotification(`車號 ${newPlateNumber} 已存在，請使用其他車號`, "error");
          // 恢復原始車牌
          this.value = currentBus.originalPlateNumber;
          currentBus.plateNumber = currentBus.originalPlateNumber;
          updateVehicleByUniqueId(currentBus);
        }
      });
      
      // 替換原有元素
      inputBusNumberElement.parentNode.replaceChild(inputBox, inputBusNumberElement);
      
      // 現在輸入框已經設定好，保存引用
      const newInputBox = document.getElementById('inputBusNumber');
      
      // 如果有選項，添加計數標記
      if (selectedItemsCount > 0) {
        addItemCountBadgeToElement(numberContainer, selectedItemsCount);
      }
    } else {
      // 如果已經是輸入框，只更新值
      inputBusNumberElement.value = bus.plateNumber || '';
      
      // 如果有選項，添加計數標記
      if (selectedItemsCount > 0) {
        addItemCountBadgeToElement(numberContainer, selectedItemsCount);
      }
    }
  } else {
    // 如果不是手動新增的車輛，顯示為純文字
    if (inputBusNumberElement.tagName === 'INPUT') {
      const textSpan = document.createElement('strong');
      textSpan.id = 'inputBusNumber';
      textSpan.textContent = bus.plateNumber || '';
      inputBusNumberElement.parentNode.replaceChild(textSpan, inputBusNumberElement);
      
      // 如果有選項，添加計數標記
      if (selectedItemsCount > 0) {
        addItemCountBadgeToElement(numberContainer, selectedItemsCount);
      }
    } else {
      // 如果已經是文字元素，只更新內容
      inputBusNumberElement.textContent = bus.plateNumber || '';
      
      // 如果有選項，添加計數標記
      if (selectedItemsCount > 0) {
        addItemCountBadgeToElement(numberContainer, selectedItemsCount);
      }
    }
  }
  
  // 清除並重新生成主要項目選項
  const mainItemsContainer = document.getElementById("mainItemsContainer");
  mainItemsContainer.innerHTML = '';
  mainItems.forEach(item => {
    const itemButton = document.createElement("div");
    itemButton.className = "quick-item";
    itemButton.textContent = item;
    itemButton.dataset.value = item;
    
    // 如果已經選過此項目，標記為已選
    if (bus.selectedMainItem === item) {
      itemButton.classList.add("selected");
    }
    
    itemButton.onclick = function() {
      mainItemsContainer.querySelectorAll(".quick-item").forEach(el => {
        el.classList.remove("selected");
      });
      this.classList.add("selected");
      
      // 儲存選擇到當前編輯的車輛對象
      bus.selectedMainItem = this.dataset.value;
      
      // 更新編輯界面以反映項目計數變化
      updateBusEditingInterface();
      updateEditingTabs();
    };
    mainItemsContainer.appendChild(itemButton);
  });

  // 清除並重新生成其他項目選項
  const otherItemsContainer = document.getElementById("otherItemsContainer");
  otherItemsContainer.innerHTML = '';
  
  // 確保 otherItems 存在且有數據
  if (!Array.isArray(otherItems) || otherItems.length === 0) {
    const noItemsMsg = document.createElement("div");
    noItemsMsg.textContent = "無可用選項";
    noItemsMsg.style.padding = "10px";
    noItemsMsg.style.color = "#666";
    otherItemsContainer.appendChild(noItemsMsg);
    return;
  }
  
  // 獲取所有不重複的類別
  let categories = [];
  try {
    // 先收集每個分類和它的代表性itemType值
    const categoryTypes = {};
    
    otherItems.forEach(item => {
      if (item && item.catolog) {
        const category = item.catolog;
        // 如果該分類還沒有itemType值，或者當前項的itemType小於已記錄的值，則更新
        if (!(category in categoryTypes) || 
            (item.itemType !== undefined && 
             (categoryTypes[category] === undefined || Number(item.itemType) < categoryTypes[category]))) {
          categoryTypes[category] = Number(item.itemType);
        }
      }
    });
    
    // 提取分類列表並按itemType從小到大排序
    categories = Object.keys(categoryTypes).sort((a, b) => {
      return categoryTypes[a] - categoryTypes[b];
    });
    
    console.log("按itemType排序的分類清單:", categories);
  } catch (e) {
    console.error("解析分類時出錯:", e);
    categories = ["未分類"]; // 默認分類
  }
  
  // 創建分類導航標籤
  const categoryNav = document.createElement("div");
  categoryNav.className = "category-nav";
  categoryNav.style.cssText = "display: flex; gap: 8px; overflow-x: auto; padding: 5px 0; margin-bottom: 8px;";

  // 創建分類標籤
  categories.forEach((category, idx) => {
    const tab = document.createElement("div");
    tab.className = "category-tab" + (idx === 0 ? " active" : "");
    tab.style.cssText = "padding: 5px 12px; background-color: #f8f9fa; border: 1px solid #ddd; border-radius: 20px; font-size: 14px; white-space: nowrap; cursor: pointer;";
    tab.textContent = category || "未分類";
    tab.dataset.index = idx;
    categoryNav.appendChild(tab);
  });

  // 創建內容容器
  const contentContainer = document.createElement("div");
  contentContainer.style.cssText = "position: relative; width: 100%; overflow: hidden;";

  // 創建滑動面板
  const pagesContainer = document.createElement("div");
  pagesContainer.className = "category-pages";
  pagesContainer.style.cssText = "display: flex; width: 100%; transition: transform 0.3s ease;";

  // 為每個分類創建一個面板
  categories.forEach((category, idx) => {
    // 創建分類面板
    const pageDiv = document.createElement("div");
    pageDiv.className = "category-page";
    pageDiv.style.cssText = "flex: 0 0 100%; width: 100%; min-height: 120px; padding: 5px; box-sizing: border-box;";
    
    // 創建內容包裹容器
    const contentWrapper = document.createElement("div");
    contentWrapper.style.cssText = "display: flex; flex-wrap: wrap; gap: 8px; max-height: 180px; overflow-y: auto; padding: 5px 0;";
    contentWrapper.style.position = "relative";
    contentWrapper.style.zIndex = "5"; // 確保在滑動層上方
    
    // 篩選該分類的項目
    const categoryItems = category === "未分類" 
      ? otherItems.filter(item => !item.catolog)
      : otherItems.filter(item => item.catolog === category);
    
    // 按 itemType 從小到大排序
    categoryItems.sort((a, b) => {
      // 確保有 itemType 值，如果沒有則設為默認值 0
      const typeA = a.itemType !== undefined ? Number(a.itemType) : 0;
      const typeB = b.itemType !== undefined ? Number(b.itemType) : 0;
      return typeA - typeB; // 從小到大排序
    });
    
    // 創建項目按鈕
    categoryItems.forEach(item => {
      if (!item || !item.itemName) return; // 跳過無效項目
      
      const itemBtn = document.createElement("div");
      itemBtn.className = "quick-other-item";
      itemBtn.style.cssText = "background: #f8f9fa; border: 1px solid #eee; border-radius: 6px; padding: 6px 12px; font-size: 14px; cursor: pointer; margin: 0; flex: 0 0 auto; max-width: calc(50% - 8px); white-space: normal;";
      
      // 根據項目類型添加樣式
      if (item.itemType === 1) {
        itemBtn.classList.add("positive-item");
      } else if (item.itemType === -1) {
        itemBtn.classList.add("negative-item");
      }
      
      itemBtn.textContent = item.itemName;
      itemBtn.dataset.value = item.itemName;
      itemBtn.dataset.type = item.itemType;
      
      // 如果此項目已選，標記為已選
      if (bus.selectedOtherItems && bus.selectedOtherItems.includes(item.itemName)) {
        itemBtn.classList.add("selected");
      }
      
      // 添加點擊事件
      itemBtn.onclick = function() {
        // 切換選中狀態
        this.classList.toggle("selected");
        
        // 確保陣列已初始化
        if (!bus.selectedOtherItems) bus.selectedOtherItems = [];
        
        const itemValue = this.dataset.value;
        const isSelected = this.classList.contains("selected");
        
        if (isSelected) {
          // 添加到選中項
          if (!bus.selectedOtherItems.includes(itemValue)) {
            bus.selectedOtherItems.push(itemValue);
          }
        } else {
          // 從選中項移除
          bus.selectedOtherItems = bus.selectedOtherItems.filter(item => item !== itemValue);
        }
        
        console.log("選中的項目:", bus.selectedOtherItems);
        
        // 更新編輯界面以反映項目計數變化
        updateItemCountBadges(bus);
        updateEditingTabs();
      };
      
      // 專門為觸屏設備添加觸摸結束事件
      itemBtn.addEventListener('touchend', function(e) {
        // 停止事件傳播，避免觸發container的touchend
        e.stopPropagation();
      }, { passive: true });
      
      contentWrapper.appendChild(itemBtn);
    });
    
    // 如果沒有項目，顯示提示訊息
    if (categoryItems.length === 0) {
      const noItemsMsg = document.createElement("div");
      noItemsMsg.textContent = "此分類無可用選項";
      noItemsMsg.style.padding = "10px";
      noItemsMsg.style.color = "#666";
      contentWrapper.appendChild(noItemsMsg);
    }
    
    pageDiv.appendChild(contentWrapper);
    pagesContainer.appendChild(pageDiv);
  });

  contentContainer.appendChild(pagesContainer);

  // 添加到主容器
  otherItemsContainer.appendChild(categoryNav);
  otherItemsContainer.appendChild(contentContainer);

  // 設置滑動功能
  setupSimpleTabs(categoryNav, pagesContainer, categories.length);

  // 修改分類標籤點擊事件
  categoryNav.querySelectorAll('.category-tab').forEach(tab => {
    tab.addEventListener('click', function() {
      // 更新標籤狀態
      categoryNav.querySelectorAll('.category-tab').forEach(t => {
        t.classList.remove('active');
        t.style.backgroundColor = '#f8f9fa';
        t.style.color = '#333';
      });
      this.classList.add('active');
      this.style.backgroundColor = '#06c755';
      this.style.color = 'white';
      
      // 獲取索引並滑動到對應頁面
      const index = Array.from(categoryNav.children).indexOf(this);
      currentSwipePage = index;
      swipeToPageImproved(index);
    });
  });

  // 預設選中第一個標籤
  if (categoryNav.querySelector('.category-tab')) {
    const firstTab = categoryNav.querySelector('.category-tab');
    firstTab.classList.add('active');
    firstTab.style.backgroundColor = '#06c755';
    firstTab.style.color = 'white';
  }
   
  // 確保新增按鈕可用
  resetSubmitButtonState();

  // 確保單一活躍標籤
  if (currentSwipePage >= 0) {
    const categoryNav = document.querySelector('.category-nav');
    if (categoryNav) {
      ensureSingleActiveTab(categoryNav, currentSwipePage);
    }
  }
}

// 輔助函數：為元素添加計數標記
function addItemCountBadgeToElement(container, count) {
  // 創建計數標記
  const badge = document.createElement("span");
  badge.id = "editingItemCountBadge";
  badge.textContent = count;
  badge.style.cssText = `
    display: inline-block;
    background-color: #06c755;
    color: white;
    border-radius: 50%;
    width: 20px;
    height: 20px;
    font-size: 12px;
    line-height: 20px;
    text-align: center;
    font-weight: bold;
    margin-left: 5px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
  `;
  
  // 添加到容器中
  container.appendChild(badge);
}

// 更新項目計數標記
function updateItemCountBadges(bus) {
  // 計算已選項目數量
  let selectedItemsCount = 0;
  if (bus.selectedMainItem) selectedItemsCount++;
  if (bus.selectedOtherItems && Array.isArray(bus.selectedOtherItems)) {
    selectedItemsCount += bus.selectedOtherItems.length;
  }
  
  // 更新編輯區域的計數標記
  const numberContainer = document.getElementById("inputBusNumber").parentNode;
  
  // 移除舊的計數標記（如果存在）
  const oldBadge = document.getElementById("editingItemCountBadge");
  if (oldBadge) oldBadge.remove();
  
  // 如果有選項，添加計數標記
  if (selectedItemsCount > 0) {
    addItemCountBadgeToElement(numberContainer, selectedItemsCount);
  }
}

// 根據唯一ID更新車輛
function updateVehicleByUniqueId(bus) {
  // 獲取關鍵信息
  const plateNumber = bus.plateNumber;
  const uniqueId = bus.uniqueId;
  const originalIndex = bus.originalIndex;
  
  console.log(`嘗試更新車輛 - ID: ${uniqueId}, 原始索引: ${originalIndex}, 新車號: ${plateNumber}`);
  
  // 更新三個關鍵列表中的車輛
  let updatedAny = false;
  
  // 優先使用原始索引更新 displayedBuses
  if (originalIndex !== undefined && displayedBuses[originalIndex]) {
    // 檢查唯一ID是否匹配，如果匹配則更新
    if (displayedBuses[originalIndex].uniqueId === uniqueId) {
      console.log(`通過原始索引 ${originalIndex} 更新顯示車輛`);
      displayedBuses[originalIndex].plateNumber = plateNumber;
      updatedAny = true;
    }
  }
  
  // 如果原始索引未能匹配，則使用唯一ID搜索
  if (!updatedAny) {
    // 在 displayedBuses 中查找
    const displayIndex = displayedBuses.findIndex(item => item.uniqueId === uniqueId);
    if (displayIndex !== -1) {
      console.log(`通過唯一ID在顯示列表找到車輛，索引: ${displayIndex}`);
      displayedBuses[displayIndex].plateNumber = plateNumber;
      updatedAny = true;
    }
    
    // 在 allDetectedBuses 中查找
    const detectedIndex = allDetectedBuses.findIndex(item => item.uniqueId === uniqueId);
    if (detectedIndex !== -1) {
      console.log(`通過唯一ID在偵測列表找到車輛，索引: ${detectedIndex}`);
      allDetectedBuses[detectedIndex].plateNumber = plateNumber;
      updatedAny = true;
    }
  }
  
  if (!updatedAny) {
    console.warn(`警告: 未找到匹配的車輛進行更新! ID: ${uniqueId}, 車牌: ${plateNumber}`);
  }
  
  // 更新編輯標籤
  updateEditingTabs();
  
  // 更新顯示
  updateDetectedBusesList();
  
  // 確保編輯狀態同步
  syncEditingStatus();
  
  // 確保所有列表中相同 uniqueId 的車輛都更新
  if (updatedAny) {
    // 確保所有列表中相同 uniqueId 的車輛都更新
    [displayedBuses, allDetectedBuses, editingBuses].forEach(list => {
      list.forEach(item => {
        if (item.uniqueId === uniqueId && item !== bus) {
          item.plateNumber = plateNumber;
        }
      });
    });
  }
}
// 確保一次只有一個分類標籤處於活動狀態
function ensureSingleActiveTab(categoryNav, activeIndex) {
  if (!categoryNav) return;
  
  const tabs = categoryNav.querySelectorAll('.category-tab');
  if (tabs.length === 0) return;
  
  // 確保 activeIndex 有效
  if (activeIndex < 0 || activeIndex >= tabs.length) {
    activeIndex = 0; // 默認選中第一個標籤
  }
  
  // 清除所有標籤的活動狀態
  tabs.forEach((tab, idx) => {
    if (idx === activeIndex) {
      tab.classList.add('active');
      tab.style.backgroundColor = '#06c755';
      tab.style.color = 'white';
    } else {
      tab.classList.remove('active');
      tab.style.backgroundColor = '#f8f9fa';
      tab.style.color = '#333';
    }
  });
}

// 改進的頁面切換函數
function swipeToPageImproved(pageIndex) {
  if (pageIndex < 0 || pageIndex >= totalPages || !pagesContainer || !categoryNav) return;
  
  // 更新當前頁碼
  currentSwipePage = pageIndex;
  
  // 更新分類標籤的選中狀態 - 確保先清除所有標籤的選中狀態
  const tabs = categoryNav.querySelectorAll('.category-tab');
  
  // 先清除所有標籤的選中狀態
  tabs.forEach(tab => {
    tab.classList.remove('active');
    tab.style.backgroundColor = '#f8f9fa';
    tab.style.color = '#333';
  });
  
  // 然後只設置目標標籤為選中狀態
  if (tabs[pageIndex]) {
    tabs[pageIndex].classList.add('active');
    tabs[pageIndex].style.backgroundColor = '#06c755';
    tabs[pageIndex].style.color = 'white';
  }
  
  // 平滑滑動到對應頁面
  pagesContainer.style.transition = 'transform 0.3s ease';
  pagesContainer.style.transform = `translateX(-${pageIndex * 100}%)`;
}
// 簡化版分類標籤設置
function setupSimpleTabs(navBar, pagesContainer, totalPages) {
  // 初始顯示第一頁
  for (let i = 0; i < totalPages; i++) {
    const page = pagesContainer.children[i];
    if (page) {
      page.style.display = i === 0 ? 'block' : 'none';
    }
  }
  
  // 為所有標籤添加點擊事件
  const tabs = navBar.querySelectorAll('.category-tab');
  tabs.forEach((tab, index) => {
    tab.addEventListener('click', function() {
      // 先清除所有標籤的活動狀態
      tabs.forEach((t) => {
        t.classList.remove('active');
        t.style.backgroundColor = '#f8f9fa';
        t.style.color = '#333';
      });
      
      // 然後設置當前標籤為活動狀態
      this.classList.add('active');
      this.style.backgroundColor = '#06c755';
      this.style.color = 'white';
      
      // 顯示對應頁面，隱藏其他頁面
      for (let i = 0; i < totalPages; i++) {
        const page = pagesContainer.children[i];
        if (page) {
          page.style.display = i === index ? 'block' : 'none';
        }
      }
    });
  });
  
  // 確保一開始只有一個標籤處於活動狀態
  if (tabs.length > 0) {
    tabs.forEach((tab, idx) => {
      if (idx === 0) {
        tab.classList.add('active');
        tab.style.backgroundColor = '#06c755';
        tab.style.color = 'white';
      } else {
        tab.classList.remove('active');
        tab.style.backgroundColor = '#f8f9fa';
        tab.style.color = '#333';
      }
    });
  }
}
// 確認取消編輯
function confirmCancelEditing(index) {
  const confirmModal = document.getElementById("confirmModal");
  const confirmMessage = document.getElementById("confirmMessage");
  const confirmYes = document.getElementById("confirmYes");
  const confirmNo = document.getElementById("confirmNo");
  
  confirmMessage.textContent = "是否取消對此車輛的編輯？";
  confirmModal.style.display = "block";
  
  // 移除之前所有的事件監聽器
  const newConfirmYes = confirmYes.cloneNode(true);
  const newConfirmNo = confirmNo.cloneNode(true);
  confirmYes.parentNode.replaceChild(newConfirmYes, confirmYes);
  confirmNo.parentNode.replaceChild(newConfirmNo, confirmNo);
  
  // 為新按鈕添加明確的事件處理程序
  newConfirmYes.addEventListener("click", function() {
    console.log("確認取消編輯，索引:", index);
    
    // 明確調用 removeEditingBus 函數
    removeEditingBus(index);
    
    // 隱藏確認對話框
    confirmModal.style.display = "none";
    
    // 更新 UI
    updateDetectedBusesList();
    updateBusSelectionInList();
  });
  
  newConfirmNo.addEventListener("click", function() {
    console.log("取消操作");
    confirmModal.style.display = "none";
  });
}

// 移除編輯中的車輛
function removeEditingBus(index) {
  console.log("開始移除編輯中車輛，索引:", index);
  
  // 檢查索引是否有效
  if (index < 0 || index >= editingBuses.length) {
    console.error("嘗試移除無效索引的車輛:", index);
    return;
  }
  
  // 保存刪除前的信息
  const removedBus = editingBuses[index];
  console.log("將要移除的車輛:", removedBus);
  
  // 在所有相關數據源中清除編輯標記
  if (removedBus && removedBus.uniqueId) {
    displayedBuses.forEach(bus => {
      if (bus.uniqueId === removedBus.uniqueId) {
        bus.isInEditing = false;
      }
    });
    
    allDetectedBuses.forEach(bus => {
      if (bus.uniqueId === removedBus.uniqueId) {
        bus.isInEditing = false;
      }
    });
  }
  
  // 移除指定索引的編輯車輛
  editingBuses.splice(index, 1);
  console.log("移除後編輯車輛列表:", editingBuses);
  
  // 調整活躍編輯索引
  if (editingBuses.length === 0) {
    // 沒有編輯中的車輛了
    activeEditingBusIndex = -1;
    isProcessingBus = false; // 重置處理狀態
    document.getElementById("busInputContainer").classList.add("hidden");
    
    // 隱藏標籤容器
    const tabsContainer = document.querySelector(".editing-tabs-container");
    if (tabsContainer) tabsContainer.style.display = "none";
  } else {
    // 保持活躍索引的有效性
    if (activeEditingBusIndex >= editingBuses.length) {
      activeEditingBusIndex = editingBuses.length - 1;
    } else if (activeEditingBusIndex === index) {
      // 如果刪除的是當前活躍車輛，選擇另一輛
      activeEditingBusIndex = 0; // 默認選擇第一輛車
    }
  }
  
  // 更新標籤和編輯界面
  updateEditingTabs();
  updateBusEditingInterface();
  
  // 更新列表中的選中狀態
  updateBusSelectionInList();
  
  // 同步編輯狀態
  syncEditingStatus();
}
// 將車牌號碼轉為大寫
function convertToUpperCase(input) {
  if (input && input.value) {
    input.value = input.value.toUpperCase();
  }
}

// 格式化車牌號碼
function formatPlateNumber(input) {
  if (!input || !input.value) return;
  
  // 移除空格並轉為大寫
  let value = input.value.replace(/\s/g, '').toUpperCase();
  
  // 台灣車牌格式驗證與標準化
  // 例如: ABC-1234 或 1234-AB
  input.value = value;
}

// 檢查是否為集團公司
function isGroupCompany(companyName) {
  // 集團公司列表，可根據需求調整
  const groupCompanies = [
    "首都客運", "臺北客運", "大都會客運", "三重客運", "台中客運"
  ];
  return groupCompanies.includes(companyName);
}

// 記錄車輛狀態
function logVehicleState(message) {
  console.log(`[車輛狀態] ${message} - ${new Date().toLocaleTimeString()}`);
}

// 開始高精度位置監控
function startHighAccuracyLocationWatching(silent = false) {
  if (watchId) {
    navigator.geolocation.clearWatch(watchId);
  }
  
  watchId = navigator.geolocation.watchPosition(
    function(position) {
      currentLatitude = position.coords.latitude;
      currentLongitude = position.coords.longitude;
      savePosition(currentLatitude, currentLongitude);
      updateLocationAccuracyIndicator(position.coords.accuracy, "即時GPS");
    },
    function(error) {
      if (!silent) {
        console.error("位置監控錯誤:", error);
      }
    },
    {
      enableHighAccuracy: true,
      maximumAge: 30000,
      timeout: 27000
    }
  );
  
  return watchId;
}

// 計算兩點間距離
function calculateDistance(lat1, lon1, lat2, lon2) {
  const R = 6371e3; // 地球半徑，單位米
  const φ1 = lat1 * Math.PI / 180;
  const φ2 = lat2 * Math.PI / 180;
  const Δφ = (lat2 - lat1) * Math.PI / 180;
  const Δλ = (lon2 - lon1) * Math.PI / 180;

  const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
            Math.cos(φ1) * Math.cos(φ2) *
            Math.sin(Δλ/2) * Math.sin(Δλ/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c; // 距離，單位米
}

// 計算中文字符數量
function countChineseChars(str) {
  if (!str) return 0;
  // 使用正則表達式匹配中文字符
  const chinesePattern = /[\u4e00-\u9fa5]/g;
  const matches = str.match(chinesePattern);
  return matches ? matches.length : 0;
}

// 根據距離添加相應的CSS類
function addDistanceClassToElement(element, distanceInMeters) {
  // 先移除所有現有的距離類
  element.classList.remove('distance-veryclose', 'distance-close', 'distance-medium', 'distance-far');
  
  // 根據距離添加對應類別
  if (distanceInMeters <= 50) {
    element.classList.add('distance-veryclose');
  } else if (distanceInMeters <= 100) {
    element.classList.add('distance-close');
  } else if (distanceInMeters <= 200) {
    element.classList.add('distance-medium');
  } else {
    element.classList.add('distance-far');
  }
}

// 顯示偵測指示器
function showDetectionIndicator(message) {
  const indicator = document.getElementById('detectionIndicator');
  if (indicator) {
    const messageElement = document.getElementById('detectionMessage');
    if (messageElement) {
      messageElement.textContent = message || '正在偵測車輛...';
    }
    indicator.classList.add('active');
  }
}

// 隱藏偵測指示器
function hideDetectionIndicator() {
  const indicator = document.getElementById('detectionIndicator');
  if (indicator) {
    indicator.classList.remove('active');
  }
}

// 顯示新偵測結果通知
function showNewDetectionNotification(count) {
  const detectionElement = document.getElementById('realTimeDetection');
  const countElement = document.getElementById('detectionCount');
  
  if (detectionElement && countElement) {
    countElement.textContent = count.toString();
    detectionElement.classList.add('show');
    
    // 5秒後自動隱藏
    setTimeout(() => {
      detectionElement.classList.remove('show');
    }, 5000);
  }
}

// 顯示零偵測結果通知
function showZeroDetectionNotification() {
  showFloatingNotification('無法偵測到任何車輛，請等待片刻再試', 'info');
}

// 提交選中的車輛
function submitSelectedBus() {
  // 防止多次點擊
  const submitButton = document.querySelector(".action-button.submit-button");
  if (submitButton) {
    if (submitButton.classList.contains("disabled")) {
      return; // 避免重複提交
    }
    submitButton.classList.add("disabled");
  }
  
  if (activeEditingBusIndex < 0 || editingBuses.length === 0) {
    showStatusMessage("沒有選中的車輛", "error");
    if (submitButton) submitButton.classList.remove("disabled");
    return;
  }
  
  const bus = editingBuses[activeEditingBusIndex];
  
  // 檢查是否選擇了主要項目
  if (!bus.selectedMainItem) {
    showStatusMessage("請選擇重點查核項目", "error");
    if (submitButton) submitButton.classList.remove("disabled");
    return;
  }
  
  // 先保存到本地存儲，以便失敗時恢復
  try {
    localStorage.setItem(`draft_${bus.uniqueId}`, JSON.stringify({
      mainItem: bus.selectedMainItem,
      otherItems: bus.selectedOtherItems,
      timestamp: Date.now()
    }));
  } catch (e) {
    console.error("保存草稿失敗:", e);
    // 繼續操作，不影響主流程
  }
  
  // 提交記錄
  submitBusRecord(bus, activeEditingBusIndex, bus.selectedMainItem, bus.selectedOtherItems)
    .then(() => {
      console.log("記錄提交成功");
      try {
        localStorage.removeItem(`draft_${bus.uniqueId}`); // 提交成功後清除草稿
      } catch (e) {
        console.error("清除草稿失敗:", e);
      }
    })
    .catch(error => {
      console.error("記錄提交失敗:", error);
      showFloatingNotification(`提交失敗：${error.message || '未知錯誤'}，請稍後重試`, "error");
      
      // 延時移除禁用狀態，防止連續點擊
      setTimeout(() => {
        if (submitButton) submitButton.classList.remove("disabled");
      }, 1500);
    });
}

// 延遲編輯
function postponeEditing() {
  // 僅隱藏編輯區域，但保留編輯狀態
  document.getElementById("busInputContainer").classList.add("hidden");
  showFloatingNotification("已暫時隱藏編輯區域，可點擊車輛繼續編輯", "info");
}

// 取消車輛輸入
function cancelBusInput() {
  if (activeEditingBusIndex >= 0 && activeEditingBusIndex < editingBuses.length) {
    confirmCancelEditing(activeEditingBusIndex);
  } else {
    document.getElementById("busInputContainer").classList.add("hidden");
    isProcessingBus = false;
  }
}

// 切換自動偵測
function toggleAutoDetect() {
  const autoDetectButton = document.getElementById("autoDetectButton");
  const countdownElement = document.getElementById("countdown");
  
  if (autoDetectInterval) {
    // 停止自動偵測
    clearInterval(autoDetectInterval);
    autoDetectInterval = null;
    
    if (countdownInterval) {
      clearInterval(countdownInterval);
      countdownInterval = null;
    }
    
    autoDetectButton.classList.remove("auto-detect-active");
    document.getElementById("autoDetectStatus").textContent = "自動偵測";
    countdownElement.textContent = "";
    
    showFloatingNotification("已停止自動偵測", "info");
  } else {
    // 啟動自動偵測
    autoDetectButton.classList.add("auto-detect-active");
    document.getElementById("autoDetectStatus").textContent = "停止偵測";
    
    // 立即執行一次偵測
    detectBuses(true);
    
    // 設置定時偵測
    countdownSeconds = 20;
    updateCountdown();
    
    countdownInterval = setInterval(updateCountdown, 1000);
    autoDetectInterval = setInterval(() => {
      detectBuses(true);
      countdownSeconds = 20;
    }, 20000);
    
    showFloatingNotification("已啟動自動偵測，每20秒更新一次", "success");
  }
}

// 更新倒數計時
function updateCountdown() {
  const countdownElement = document.getElementById("countdown");
  if (countdownElement) {
    if (countdownSeconds > 0) {
      countdownElement.textContent = `下次自動偵測：${countdownSeconds} 秒`;
      countdownSeconds--;
    } else {
      countdownElement.textContent = "正在偵測...";
    }
  }
}
// 位置模態框相關函數
function openLocationModal() {
  document.getElementById("locationModal").style.display = "block";
  refreshLocationList(); // 打開時刷新位置列表
}

function closeLocationModal() {
  document.getElementById("locationModal").style.display = "none";
}

// 刷新附近位置列表
function refreshLocationList() {
  showLoading();
  const locationList = document.getElementById("locationList");
  locationList.innerHTML = ""; // 清空現有列表
  
  // 獲取當前位置
  getCurrentPosition().then(posResult => {
    if (!posResult.success) {
      locationList.innerHTML = `<div class="no-data-message">無法獲取位置，請確認位置權限已開啟</div>`;
      hideLoading();
      return;
    }
    
    // 獲取附近路口
    fetchWithRetry(`${base_url}monitor/intersections?latitude=${currentLatitude}&longitude=${currentLongitude}`, {}, 3)
      .then(response => response.json())
      .then(data => {
        if (data && data.intersections && data.intersections.length > 0) {
          intersections = data.intersections;
          
          // 顯示附近路口列表
          intersections.forEach((item, index) => {
            const locationItem = document.createElement("div");
            locationItem.className = "location-item";
            locationItem.textContent = item.name;
            locationItem.onclick = function() {
              document.getElementById("location").value = item.name;
              closeLocationModal();
            };
            locationList.appendChild(locationItem);
          });
        } else {
          locationList.innerHTML = `<div class="no-data-message">附近無可用路口資訊</div>`;
        }
        hideLoading();
      })
      .catch(error => {
        console.error("獲取路口數據失敗:", error);
        locationList.innerHTML = `<div class="no-data-message">獲取路口資訊失敗，請稍後再試</div>`;
        hideLoading();
      });
  });
}

// 選擇隨車稽查
function selectOnBoardInspection() {
  document.getElementById("location").value = "隨車稽查";
  closeLocationModal();
}

// 地址偵測功能
function detectAddress() {
  showLoading();
  getCurrentPosition().then(posResult => {
    if (!posResult.success) {
      showStatusMessage("無法獲取位置，請確認位置權限已開啟", "error", true);
      hideLoading();
      return;
    }
    
    // 嘗試使用反向地理編碼獲取地址
    fetchWithRetry(`${base_url}monitor/geocode?latitude=${currentLatitude}&longitude=${currentLongitude}`, {}, 3)
      .then(response => response.json())
      .then(data => {
        hideLoading();
        if (data && data.address) {
          document.getElementById("location").value = data.address;
          closeLocationModal();
        } else {
          showStatusMessage("無法獲取當前地址信息", "warning", true);
        }
      })
      .catch(error => {
        console.error("獲取地址失敗:", error);
        hideLoading();
        showStatusMessage("獲取地址失敗，請使用其他方式選擇位置", "error", true);
      });
  });
}

// 手動輸入車輛相關函數
function openManualInputModal() {
  // 重置表單
  document.getElementById("manualPlateNumber").value = "";
  document.getElementById("manualCompany").value = "";
  document.getElementById("manualRoute").value = "";
  document.getElementById("manualDirection").value = "0";
  
  // 重置方向按鈕
  document.querySelectorAll(".direction-btn").forEach(btn => {
    btn.classList.remove("selected");
  });
  document.querySelector(".direction-btn[data-value='0']").classList.add("selected");
  
  // 隱藏錯誤訊息
  document.getElementById("manualInputError").style.display = "none";
  
  // 顯示模態框
  document.getElementById("manualInputModal").style.display = "block";
  
  // 聚焦車號輸入框
  setTimeout(() => document.getElementById("manualPlateNumber").focus(), 100);
}

function closeManualInputModal() {
  document.getElementById("manualInputModal").style.display = "none";
}

// 添加手動輸入的車輛
function addManualBus() {
  // 獲取輸入值
  const plateNumber = document.getElementById("manualPlateNumber").value.trim();
  const company = document.getElementById("manualCompany").value;
  const route = document.getElementById("manualRoute").value.trim();
  const direction = document.getElementById("manualDirection").value;
  
  // 驗證
  if (!plateNumber) {
    const errorElement = document.getElementById("manualInputError");
    errorElement.textContent = "請輸入車號";
    errorElement.style.display = "block";
    return;
  }
  
  if (!company) {
    const errorElement = document.getElementById("manualInputError");
    errorElement.textContent = "請選擇公司";
    errorElement.style.display = "block";
    return;
  }
  
  // 創建新車輛對象
  const newBus = {
    plateNumber: plateNumber,
    operatorName: company,
    routeName: { chinese: route || "手動新增" },
    direction: direction,
    position: {
      latitude: currentLatitude,
      longitude: currentLongitude
    },
    uniqueId: uuid.v4(),
    isManualInput: true,
    lastUpdated: Date.now()
  };
  
  // 添加到列表
  addNewDetectedBus(newBus);
  
  // 更新UI
  updateDetectedBusesList();
  
  // 關閉模態框
  closeManualInputModal();
  
  // 提示成功
  showFloatingNotification(`已新增車輛: ${plateNumber}`, "success");
  
  // 選擇此車輛進行編輯
  const index = displayedBuses.findIndex(bus => bus.uniqueId === newBus.uniqueId);
  if (index !== -1) {
    selectBusForInput(displayedBuses[index], index, true);
  }
}

// 顯示已偵測車輛的函數
function showDetectedBuses() {
  // 隱藏通知小卡
  const detectionElement = document.getElementById('realTimeDetection');
  if (detectionElement) {
    detectionElement.classList.remove('show');
  }
  
  // 滾動到列表區域
  const listContainer = document.getElementById('detectedBusesContainer');
  if (listContainer) {
    listContainer.scrollIntoView({ behavior: "smooth" });
  }
}

// 為方向按鈕添加事件處理
document.addEventListener('DOMContentLoaded', function() {
  // 設置方向按鈕點擊事件
  const directionButtons = document.querySelectorAll('.direction-btn');
  directionButtons.forEach(btn => {
    btn.addEventListener('click', function() {
      // 清除所有按鈕的選中狀態
      directionButtons.forEach(b => b.classList.remove('selected'));
      
      // 設置當前按鈕為選中
      this.classList.add('selected');
      
      // 更新隱藏輸入框的值
      document.getElementById('manualDirection').value = this.dataset.value;
    });
  });
});
// 使用優化器重新定義關鍵函數
const debouncedInitMarquees = EventOptimizer.debounce(initializeMarquees, 200);
const throttledUpdateBusSelectionInList = EventOptimizer.throttle(updateBusSelectionInList, 300);
const bulletproofDetectBuses = EventOptimizer.bulletproof(detectBuses, 300, 2000);

// 添加資源釋放代碼
window.addEventListener('beforeunload', function() {
  // 清除位置監視
  if (watchId) {
    navigator.geolocation.clearWatch(watchId);
    watchId = null;
  }
  
  // 清除所有計時器
  if (globalLoadingTimeout) {
    clearTimeout(globalLoadingTimeout);
    globalLoadingTimeout = null;
  }
  
  if (autoDetectInterval) {
    clearInterval(autoDetectInterval);
    autoDetectInterval = null;
  }
  
  if (countdownInterval) {
    clearInterval(countdownInterval);
    countdownInterval = null;
  }
  
  // 保存未完成的編輯
  try {
    if (editingBuses.length > 0) {
      localStorage.setItem('pending_edits', JSON.stringify(editingBuses.map(bus => ({
        uniqueId: bus.uniqueId,
        plateNumber: bus.plateNumber,
        selectedMainItem: bus.selectedMainItem,
        selectedOtherItems: bus.selectedOtherItems,
        timestamp: Date.now()
      }))));
    } else {
      localStorage.removeItem('pending_edits');
    }
  } catch (e) {
    console.error('保存未完成編輯失敗:', e);
  }
});

// 資源監控系統
const ResourceMonitor = {
  memoryWarningThreshold: 150, // MB
  lastMemoryCheck: 0,
  checkInterval: 60000, // 1分鐘檢查一次
  
  // 初始化監控
  init: function() {
    // 定期檢查
    setInterval(() => this.checkResources(), this.checkInterval);
    
    // 首次檢查
    this.checkResources();
    
    return this;
  },
  
  // 檢查資源使用情況
  checkResources: function() {
    // 檢查記憶體使用 (僅在支持的瀏覽器)
    if (performance && performance.memory) {
      const memoryUsage = performance.memory.usedJSHeapSize / (1024 * 1024); // MB
      console.log(`記憶體使用: ${memoryUsage.toFixed(2)}MB`);
      
      // 如果超過閾值，嘗試釋放記憶體
      if (memoryUsage > this.memoryWarningThreshold) {
        console.warn(`記憶體使用超過閾值: ${memoryUsage.toFixed(2)}MB`);
        this.cleanupResources();
      }
    }
    
    // 檢查 localStorage 大小
    try {
      let total = 0;
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        const value = localStorage.getItem(key);
        total += (key.length + value.length) * 2; // 近似 UTF-16 編碼大小
      }
      
      // 轉換為 KB
      const totalKB = total / 1024;
      console.log(`localStorage 使用: ${totalKB.toFixed(2)}KB`);
      
      // localStorage 超過 4MB 時清理過期項目
      if (totalKB > 3000) {
        console.warn('localStorage 接近上限，清理過期項目');
        this.cleanupLocalStorage();
      }
    } catch (e) {
      console.error('檢查 localStorage 大小失敗:', e);
    }
  },
  
  // 清理資源
  cleanupResources: function() {
    // 釋放圖片快取
    const images = document.querySelectorAll('img');
    images.forEach(img => {
      if (!isElementVisible(img)) {
        img.src = ''; // 釋放不可見圖片資源
      }
    });
    
    // 嘗試使用垃圾回收
    if (window.gc) {
      try {
        window.gc();
        console.log('已嘗試垃圾回收');
      } catch (e) {} // 忽略不支持的錯誤
    }
    
    // 清理過期的數據
    this.cleanupLocalStorage();
  },
  
  // 清理本地存儲
  cleanupLocalStorage: function() {
    try {
      // 清理超過3小時的提交記錄
      const clearedSubmissions = safeStorage.clearExpired("submitted_", 3 * 60 * 60 * 1000);
      console.log(`已清理 ${clearedSubmissions} 條過期提交記錄`);
      
      // 清理超過24小時的草稿
      let clearCount = 0;
      Object.keys(localStorage).forEach(key => {
        if (key.startsWith('draft_')) {
          try {
            const data = JSON.parse(localStorage.getItem(key));
            if (Date.now() - data.timestamp > 24 * 60 * 60 * 1000) {
              localStorage.removeItem(key);
              clearCount++;
            }
          } catch (e) {
            // 無法解析，直接刪除
            localStorage.removeItem(key);
            clearCount++;
          }
        }
      });
      
      console.log(`已清理 ${clearCount} 個過期草稿`);
    } catch (e) {
      console.error('清理本地存儲失敗:', e);
    }
  }
};

// 在應用啟動時初始化資源監控
document.addEventListener('DOMContentLoaded', function() {
  // 原有的 DOMContentLoaded 處理...
  
  // 添加資源監控
  ResourceMonitor.init();
});
</script>
</html>
