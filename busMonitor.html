<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>車輛查核</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/uuid/8.3.2/uuid.min.js"></script>
    <script src="https://static.line-scdn.net/liff/edge/2/sdk.js"></script>
    <style>
      body {
        font-family: "Noto Sans TC", Arial, sans-serif;
        background-color: #f7f7f7;
        margin: 0;
        padding: 0;
        color: #000;
      }

      .container {
        max-width: 500px;
         margin: 0 auto; /* 修改為0 auto使頂部無間距 */
        background: white;
        padding: 25px;
        border-radius: 12px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
      }

      h2 {
        margin-top: 10px; /* 減少上邊距 */
        color: #06c755;
        text-align: center;
        margin-bottom: 25px;
        font-weight: 600;
     border-bottom: none; /* 移除底部分隔線 */
        padding-bottom: 15px;
      }
/* 車輛距離黃白漸層底色樣式 */
.bus-plate.distance-veryclose { 
  background: linear-gradient(to right, #ffeb3b 100%, #ffffff 100%);
  border: 1px solid #ffc107;
}

.bus-plate.distance-close { 
  background: linear-gradient(to right, #ffeb3b 75%, #ffffff 75%);
  border: 1px solid #ffd54f;
}

.bus-plate.distance-medium { 
  background: linear-gradient(to right, #ffeb3b 50%, #ffffff 50%);
  border: 1px solid #ffe082;
}

.bus-plate.distance-far { 
  background: linear-gradient(to right, #ffeb3b 25%, #ffffff 25%);
  border: 1px solid #ffecb3;
}

/* 自動偵測按鈕啟動樣式 */
.utility-button.auto-detect-active {
  background-color: #06c755 !important;
  color: white !important;
  border-color: #04a73e !important;
  box-shadow: 0 0 8px rgba(6, 199, 85, 0.5) !important;
  transform: translateY(-2px) !important;
  position: relative;
  animation: pulse 1.5s infinite;
}
      .form-group {
        margin-bottom: 20px;
        text-align: left;
      }

      label {
        display: block;
        margin-bottom: 6px;
        font-weight: 500;
        color: #555;
      }

      .required::after {
        content: "*";
        color: #e74c3c;
        margin-left: 4px;
      }

      /* 輸入框樣式 */
      .input-group {
        display: flex;
        align-items: center;
      }

      .input-group input {
        flex: 1;
        border-top-right-radius: 0;
        border-bottom-right-radius: 0;
      }

      .input-group .icon-button {
        width: 46px;
        height: 46px;
        border: 1px solid #ddd;
        border-left: none;
        background-color: #f8f9fa;
        border-top-right-radius: 6px;
        border-bottom-right-radius: 6px;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        transition: background-color 0.2s;
      }

      .input-group .icon-button:hover {
        background-color: #e9ecef;
      }

      .input-group .icon-button i {
        color: #06c755;
      }

      input,
      select,
      textarea {
        width: 100%;
        padding: 12px;
        border: 1px solid #ddd;
        border-radius: 6px;
        font-size: 16px;
        transition: border 0.3s;
        box-sizing: border-box;
      }

      input:focus,
      select:focus,
      textarea:focus {
        border-color: #06c755;
        outline: none;
        box-shadow: 0 0 0 2px rgba(6, 199, 85, 0.1);
      }

      /* 新增：檢測車輛卡片樣式 */
      .bus-card {
        background-color: #fff;
        border-radius: 8px;
        border: 1px solid #ddd;
        margin-bottom: 15px;
        overflow: hidden;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        transition: all 0.3s ease;
      }

      .bus-card:hover {
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      }

      .bus-card-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 15px;
        background-color: #f8f9fa;
        border-bottom: 1px solid #eee;
      }

      .bus-card-company {
        font-weight: bold;
        color: #06c755;
      }

      .bus-card-plate {
        font-weight: bold;
        background-color: #ffeb3b;
        padding: 3px 8px;
        border-radius: 4px;
      }

      .bus-card-body {
        padding: 15px;
      }

      .bus-card-route {
        margin-bottom: 10px;
        font-size: 15px;
      }

      .bus-card-actions {
        display: flex;
        flex-direction: column;
        gap: 10px;
        margin-top: 10px;
      }

      button {
        width: 100%;
        padding: 14px;
        background-color: #06c755;
        color: white;
        border: none;
        border-radius: 6px;
        font-size: 18px;
        font-weight: 500;
        cursor: pointer;
        transition: 0.3s;
        margin-top: 10px;
      }

      button:hover {
        background-color: #04a73e;
        box-shadow: 0 4px 8px rgba(6, 199, 85, 0.2);
      }

      .secondary-button {
        background-color: #f1f1f1;
        color: #333;
      }

      .secondary-button:hover {
        background-color: #e5e5e5;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      }

      /* 簡化選項樣式 */
      .quick-items {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-bottom: 10px;
      }

      .quick-item {
  background-color: #f1f1f1;
  border-radius: 20px;
  padding: 8px 14px; /* 放大按鈕尺寸 */
  font-size: 15px; /* 放大字體 */
  cursor: pointer;
  border: 1px solid #ddd;
  transition: all 0.2s ease;
  margin-bottom: 5px; /* 增加間距 */
      }

      .quick-item.selected {
  background-color: #06c755;
  color: white;
  border-color: #04a73e;
  box-shadow: 0 2px 6px rgba(6, 199, 85, 0.3);
  transform: translateY(-2px);
  position: relative;
  font-weight: bold;
      }
      .quick-item.selected::after {
  content: "✓";
  position: absolute;
  top: -8px;
  right: -8px;
  background-color: #04a73e;
  color: white;
  font-size: 12px;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  border: 2px solid white;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}
      /* 其他項目簡化樣式 */
      .quick-other-items {
  touch-action: pan-y; /* 允許垂直滑動，但不影響水平滑動 */
      }
      .swipe-container, 
.content-container {
  width: 100%;
  overflow: hidden;
  position: relative;
}
      .quick-other-item {
  touch-action: manipulation;
  -webkit-tap-highlight-color: transparent;
  position: relative;
      }
      /* 修正滑動容器問題 */
.category-pages {
  display: block;
  width: 100%;
}
      .quick-other-item.selected {
  background-color: #e7f3fe;
  color: #004085;
  border-color: #b8daff;
  border-width: 2px;
  font-weight: bold;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
  transform: translateY(-2px);
      }
/* 為其他項目添加選中標記 */
.quick-other-item.selected::after {
  content: "✓";
  position: absolute;
  top: -8px;
  right: -8px;
  background-color: #007bff;
  color: white;
  font-size: 12px;
  width: 18px;
  height: 18px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  border: 2px solid white;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}
      .status-message {
        margin-top: 15px;
        padding: 10px;
        border-radius: 5px;
        text-align: center;
        display: none;
      }

      .status-message.success {
        background-color: #d4edda;
        color: #155724;
        display: block;
      }

      .status-message.error {
        background-color: #f8d7da;
        color: #721c24;
        display: block;
      }

      .status-message.info {
        background-color: #e7f3fe;
        color: #004085;
        display: block;
      }

      /* 即時偵測結果小卡 */
      .real-time-detection {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background-color: #06c755;
        color: white;
        padding: 10px 15px;
        border-radius: 30px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        z-index: 99;
        display: flex;
        align-items: center;
        gap: 10px;
        opacity: 0;
        transform: translateY(20px);
        transition: all 0.3s ease;
        cursor: pointer;
      }

      .real-time-detection.show {
        opacity: 1;
        transform: translateY(0);
      }

      .detection-count {
        background-color: white;
        color: #06c755;
        font-weight: bold;
        border-radius: 50%;
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      
      /* 動作按鈕樣式 */
      .action-button {
        padding: 10px;
        border-radius: 4px;
        text-align: center;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
      }
      
      .submit-button {
        background-color: #06c755;
        color: white;
      }
      
      .submit-button:hover {
        background-color: #04a73e;
      }
      
      .remove-button {
        background-color: #f8d7da;
        color: #721c24;
      }
      
      .remove-button:hover {
        background-color: #f5c6cb;
      }
      
 @media (max-width: 480px) {
    .utility-buttons {
      grid-template-columns: repeat(3, 1fr);
    }
  }
.utility-buttons {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 8px;
  margin: 15px 0;
}
      .utility-button {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 10px 8px;
  border-radius: 6px;
  background-color: #f1f1f1;
  color: #333;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  border: 1px solid #ddd;
  gap: 5px;
  touch-action: manipulation;
  -webkit-tap-highlight-color: transparent;
      }
      
      .utility-button:hover {
        background-color: #e5e5e5;
      }
      .utility-button i {
  font-size: 18px;
  margin-bottom: 4px;
}
      .utility-button.primary {
        background-color: #e7f3fe;
        color: #004085;
        border-color: #b8daff;
      }
      
      .utility-button.primary:hover {
        background-color: #d1e7ff;
      }
      
      /* 無檢測結果時的樣式 */
      .no-buses-message {
  text-align: center;
  padding: 30px 0; /* 只保留上下內邊距，左右邊距設為0 */
  background-color: #f8f9fa;
  border-radius: 8px;
  color: #6c757d;
  margin: 20px 0;
  width: 100%;
  box-sizing: border-box;
  display: block; /* 確保是塊級元素 */
      }
      /* 確保內部文字左右有適當距離 */
.no-buses-message p {
  padding: 0 20px;
  margin: 0;
}
           
      /* 查詢歷史樣式 */
      .history-list {
        margin-top: 15px;
      }
      
      .history-item {
        padding: 10px;
        border-bottom: 1px solid #eee;
        display: flex;
        justify-content: space-between;
      }
      
      .history-time {
        color: #6c757d;
        font-size: 12px;
      }
      
      /* 狀態標籤 */
      .status-tag {
        display: inline-block;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 12px;
        font-weight: 500;
        margin-left: 5px;
      }
      
      .status-processing {
        background-color: #fff3cd;
        color: #856404;
      }
      
      .status-submitted {
        background-color: #d4edda;
        color: #155724;
      }
      
      /* 位置項目樣式 */
      .location-item {
        padding: 12px;
        border-bottom: 1px solid #eee;
        cursor: pointer;
      }
      
      .location-item:hover {
        background-color: #f9f9f9;
      }
      
      /* 檢測按鈕容器樣式 */
      .detect-button-container {
  margin-bottom: 15px;
  text-align: center;
  display: flex;
  gap: 10px;
  justify-content: center;
      }
      
      .detect-button {
  width: auto !important;
  padding: 10px 15px !important;
  margin: 0 !important;
  flex: 1;
      }
     #onBoardInspectionButton {
  background-color: #f8f9fa;
  color: #333;
}

#onBoardInspectionButton:hover {
  background-color: #e9ecef;
} 
      /* 無數據提示樣式 */
      .no-data-message {
        text-align: center;
        padding: 15px;
        color: #6c757d;
        font-style: italic;
      }
      
      /* 彈窗模態樣式補充 */
      .modal {
        display: none;
        position: fixed;
        z-index: 100;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        animation: fadeIn 0.3s ease;
      }
      
      @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
      }
      
      .modal-content {
        background-color: #fefefe;
        margin: 15% auto;
        padding: 20px;
        border-radius: 10px;
        width: 80%;
        max-width: 500px;
        max-height: 70vh;
        overflow-y: auto;
        animation: slideDown 0.3s ease;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      }
      
      @keyframes slideDown {
        from { transform: translateY(-50px); opacity: 0; }
        to { transform: translateY(0); opacity: 1; }
      }
      
      .button-group {
        display: flex;
        gap: 10px;
        margin-top: 20px;
      }
      
      /* 載入中覆蓋層樣式補充 */
      .loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(255, 255, 255, 0.9);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 2000;
      }
      
      .spinner {
        width: 40px;
        height: 40px;
        border: 4px solid #f3f3f3;
        border-top: 4px solid #06c755;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }
      
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
      
      .hidden {
        display: none;
      }
      
      /* 公司信息與品牌 */
      .line-brand {
        text-align: center;
        margin-top: 20px;
        font-size: 14px;
        color: #999;
        padding-top: 15px;
        border-top: 1px solid #f0f0f0;
      }
      
      /* 檢測結果區域 */
      .detected-buses-container {
        margin-top: 20px;
        margin-bottom: 20px;
      }
      
      .detection-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
  flex-wrap: wrap;
      }
      .detection-title-area {
  display: flex;
  align-items: center;
}
      
      .detection-header h3 {
        margin: 0;
        color: #06c755;
      }
      /* 簡易車輛列表樣式 */
.simple-bus-list {
    display: grid;
    grid-template-columns: repeat(2, 1fr); /* 改回固定的2列佈局 */
    gap: 10px;
    margin-top: 15px;
}
/* 路線容器固定寬度 */
.bus-route-container {
  width: 125px;            /* 固定寬度 */
  overflow: hidden;    
  white-space: nowrap;
  position: relative;
  margin-right: 0px;      /* 右側間距 */
}
.simple-bus-item {
  background-color: #f8f9fa;
  border: 1px solid #eee;
  border-radius: 6px;
  display: flex;
  justify-content: flex-start;  /* 改為從左開始排列 */
  align-items: center;
  width: 100%;
  padding: 8px 6px;
  box-sizing: border-box;
  margin: 0;
  min-height: 45px;
  overflow: hidden;
    height: 45px; /* 固定高度 */
  margin-bottom: 0;
  transform: translate3d(0, 0, 0); /* 啟用硬體加速，減少重繪 */
  transition: transform 0.2s ease, background-color 0.2s ease;
}
button, .utility-button, .quick-item, .simple-bus-item {
  touch-action: manipulation;
  -webkit-tap-highlight-color: transparent;
}
.simple-bus-item strong {
  font-size: 15px; /* 車牌號碼稍微大一點 */
}

.simple-bus-item:hover {
  background-color: #e7f3fe;
  border-color: #b8daff;
  transform: translateY(-2px);
  box-shadow: 0 3px 6px rgba(0, 0, 0, 0.1);
}
/* 添加到您的CSS中 */
@font-face {
  font-family: 'FontAwesome';
  font-display: swap; /* 改善字體載入 */
}
.company-label {
 color: #06c755;
  font-weight: 500;
  font-size: 15px; /* 減小公司名稱字體 */
}
/* 然後在媒體查詢中處理響應式 */
@media (min-width: 481px) {
  .simple-bus-list {
    grid-template-columns: repeat(2, 1fr); /* 大螢幕使用2列 */
  }
}

@media (max-width: 480px) {
  .simple-bus-list {
    grid-template-columns: repeat(2, 1fr); /* 小螢幕仍保持2列 */
  }
}

@media (max-width: 320px) {
  .simple-bus-list {
    grid-template-columns: 1fr; /* 只有在非常小的螢幕(320px以下)才使用單列 */
  }
}
#detectedBusesList {
  padding: 0;
  margin: 0;
  width: 100%;
}
/* 固定輸入區域樣式 */
.bus-input-container {
  background-color: #fff;
  border: 1px solid #ddd;
  border-radius: 8px;
  margin-top: 20px;
  margin-bottom: 20px;
  box-shadow: 0 3px 8px rgba(0, 0, 0, 0.08);
  overflow: hidden;
  transition: all 0.3s ease;
}
.bus-route {
  color: #004085;
  font-weight: 500;
  font-size: 15px;
  max-width: 70%;
  overflow: hidden;
  white-space: nowrap;
  position: relative;
}
.bus-plate {
  flex-shrink: 0;
  width: 65px !important; /* 固定統一寬度 */
  min-width: 65px !important;
  max-width: 65px !important;
  text-align: center;
  background-color: #ffeb3b;
  padding: 3px 4px;
  border-radius: 4px;
  font-weight: bold;
  font-size: 14px;
  margin-left: 4px;
  white-space: nowrap;
  overflow: hidden; /* 過長時隱藏 */
}

.bus-info-header {
  background-color: #f8f9fa;
  padding: 15px;
  border-bottom: 1px solid #eee;
}

.route-info {
  color: #004085; /* 加深顏色讓路線更明顯 */
  margin-top: 0;
  margin-bottom: 5px;
  font-size: 18px;
  font-weight: 500; /* 加粗 */
  text-align: left; /* 添加這行使文字靠左 */
}

.input-section {
  padding: 15px;
    overflow-x: hidden; /* 防止水平溢出 */
}
  * {
    touch-action: manipulation; /* 優化觸控體驗 */
  }
.input-actions {
  display: flex;
  gap: 10px;
  margin-top: 15px;
}

.cancel-button {
  background-color: #f1f1f1;
  color: #333;
}

.cancel-button:hover {
  background-color: #e5e5e5;
}

/* 倒數計時容器 */
.countdown-container {
    text-align: center;
    margin-top: 8px;
    margin-bottom: 8px;
    color: #06c755;
    font-size: 14px;
    font-weight: bold;
}
/* 開關按鈕樣式 */
.switch-container {
  display: flex;
  align-items: center;
  margin-left: 10px;
  font-size: 14px;
}

.switch {
  position: relative;
  display: inline-block;
  width: 40px;
  height: 20px;
  margin-right: 6px;
}

.switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #ccc;
  transition: .4s;
  border-radius: 34px;
}

.slider:before {
  position: absolute;
  content: "";
  height: 16px;
  width: 16px;
  left: 2px;
  bottom: 2px;
  background-color: white;
  transition: .4s;
  border-radius: 50%;
}

input:checked + .slider {
  background-color: #06c755;
}

input:checked + .slider:before {
  transform: translateX(20px);
}
 /* 添加到現有樣式的最後 */
  /* 跑馬燈效果樣式 */
  .text-marquee {
  display: inline-block;
  white-space: nowrap;
  overflow: hidden;
  width: 100%;
  color: #004085;
  font-weight: 500;
  flex: 1;
  will-change: transform; /* 優化硬體加速 */
  transform: translateZ(0); /* 啟用硬體加速 */
  }
  
.text-marquee.scrolling {
  animation: marquee-transform var(--scroll-duration, 15s) linear infinite;
  animation-fill-mode: forwards;
  backface-visibility: hidden; /* 減少渲染層 */
  contain: paint; /* 告訴瀏覽器只需重新繪製此元素 */
}
/* 優化的跑馬燈動畫，使用 transform 而非 left/right */
@keyframes marquee-transform {
  0% { transform: translateX(0); }
  100% { transform: translateX(-100%); }
}
/* 列表項中的跑馬燈速度更快 */
.list-marquee.scrolling {
  position: relative;
  width: auto;
  padding-left: 0;
  animation: continuous-scroll-transform 15s linear infinite;
  white-space: nowrap;
  backface-visibility: hidden;
  contain: paint;
}
/* 優化的連續滾動動畫 */
@keyframes continuous-scroll-transform {
  0% { transform: translateX(100%); }
  100% { transform: translateX(-100%); }
}
/* 對於低效能設備的備選方案 */
@media (prefers-reduced-motion: reduce) {
  .text-marquee.scrolling,
  .list-marquee.scrolling {
    animation: none; /* 禁用動畫 */
    text-overflow: ellipsis; /* 使用省略號 */
  }
}
/* 添加額外空間，確保文本之間有適當間距 */
.list-marquee.scrolling::after {
content: "　"; /* 使用單個全角空格作為間隔 */
}
  .text-marquee:hover {
    animation-play-state: paused;
  }
  :root {
  --character-scroll-speed: 0.7s; /* 每個字符滾動所需時間 */
}
  .text-marquee:hover {
    animation-play-state: paused;
  }
  :root {
  --character-scroll-speed: 0.7s; /* 每個字符滾動所需時間 */
}
@keyframes continuous-scroll {
  0% { transform: translateX(100%); }    /* 從完全隱藏的右側開始 */
  100% { transform: translateX(-100%); }  /* 滾動到左側結束 */
}
    @keyframes marquee-scroll {
    0% { transform: translateX(0); }
    100% { transform: translateX(-100%); }
  }
  
  /* 調整路線顯示容器 */
  .route-info {
  color: #004085;
  margin-top: 0;
  margin-bottom: 5px;
  font-size: 18px;
  font-weight: 500;
  text-align: left;
  width: 100%;
  overflow: hidden;
  }
  
  /* 確保跑馬燈容器寬度正確 */
  #inputBusRoute {
  width: 100%;
  overflow: hidden;
  position: relative;
  }
/* 響應式調整 */
@media (max-width: 480px) {
  .switch-container {
    font-size: 12px;
  }
  
  .switch {
    width: 36px;
    height: 18px;
  }
  
  .slider:before {
    height: 14px;
    width: 14px;
  }
  
  input:checked + .slider:before {
    transform: translateX(18px);
  }
}

/* 添加脈動動畫效果 */
@keyframes pulse {
  0% { box-shadow: 0 0 0 0 rgba(6, 199, 85, 0.7); }
  70% { box-shadow: 0 0 0 10px rgba(6, 199, 85, 0); }
  100% { box-shadow: 0 0 0 0 rgba(6, 199, 85, 0); }
}

/* 倒數計時文字樣式 */
.countdown-container {
  font-weight: bold;
  color: #06c755;
}
.action-button.disabled {
    opacity: 0.7;
    pointer-events: none;
    cursor: not-allowed;
}
.simple-bus-item.selected-bus-item {
  border: 2px solid #06c755;
  background-color: rgba(6, 199, 85, 0.1);
  position: relative;
}

.simple-bus-item.selected-bus-item::after {
  content: "編輯中";
  position: absolute;
  top: -8px;
  right: -8px;
  background-color: #06c755;
  color: white;
  font-size: 10px;
  padding: 2px 6px;
  border-radius: 10px;
}
 /* 位置精度指示器樣式 */
  .location-accuracy-container {
    margin-top: 5px;
    font-size: 12px;
  }
  
  .location-accuracy {
    display: flex;
    align-items: center;
    gap: 5px;
  }
  .utility-button.detecting {
  background-color: #ffeb3b !important;
  color: #333 !important;
  border-color: #ffc107 !important;
  box-shadow: 0 0 8px rgba(255, 193, 7, 0.7) !important;
  position: relative;
  animation: detecting-pulse 1.5s infinite;
}
/* 添加脈動動畫效果 */
@keyframes detecting-pulse {
  0% { box-shadow: 0 0 0 0 rgba(255, 193, 7, 0.7); }
  70% { box-shadow: 0 0 0 10px rgba(255, 193, 7, 0); }
  100% { box-shadow: 0 0 0 0 rgba(255, 193, 7, 0); }
}
/* 偵測指示器樣式 */
.detection-indicator {
  position: fixed;
  bottom: 70px;
  left: 50%;
  transform: translateX(-50%);
  background-color: rgba(0, 0, 0, 0.7);
  color: white;
  padding: 8px 15px;
  border-radius: 20px;
  font-size: 14px;
  z-index: 1000;
  display: flex;
  align-items: center;
  gap: 8px;
  opacity: 0;
  transition: opacity 0.3s;
  pointer-events: none;
}
.detection-indicator.active {
  opacity: 1;
}

.detection-indicator .spinner {
  width: 16px;
  height: 16px;
  border: 2px solid rgba(255, 255, 255, 0.3);
  border-top: 2px solid #fff;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}
.direction-badge {
  display: inline-block;
  background-color: #007bff;
  color: white;
  border-radius: 3px;
  padding: 0 3px;
  margin-right: 3px;
  font-size: 12px;
  line-height: 1.5;
}

.direction-tag {
  display: inline-block;
  background-color: #e7f3fe;
  color: #004085;
  border-radius: 4px;
  padding: 2px 6px;
  font-size: 14px;
  flex-shrink: 0; /* 防止被壓縮 */
  margin-left: 10px;
}

.route-direction-container {
  display: flex;
  justify-content: space-between;
  align-items: center;
  width: 100%;
  flex-direction: row; /* 確保水平排列 */
}
/* 去程 - 藍色系 */
.bus-plate.direction-go {
  border-left: 8px solid #007bff !important;
}

/* 返程 - 綠色系 */
.bus-plate.direction-back {
  border-left: 8px solid #28a745 !important;
}
.direction-buttons {
  display: flex;
  gap: 10px;
  margin-top: 5px;
}

.direction-btn {
  background-color: #f8f9fa;
  color: #333;
  border: 1px solid #ddd;
  position: relative;
  overflow: hidden;
}

.direction-btn.selected {
  background-color: #e9ecef;
  box-shadow: inset 0 0 10px rgba(0,0,0,0.1);
}
.direction-legend {
  display: flex;
  gap: 10px;
  margin-left: 10px;
  font-size: 12px;
}

.direction-tag.go-tag {
  background-color: #007bff;
  color: white;
}

.direction-tag.back-tag {
  background-color: #28a745;
  color: white;
}
.direction-btn[data-value="0"] {
  border-left: 5px solid #007bff;
}
.direction-btn[data-value="1"] {
  border-left: 5px solid #28a745;
}
.direction-btn.selected[data-value="0"] {
  border-left: 5px solid #007bff;
  background-color: #cfe2ff; /* 淺藍底 */
}

.direction-btn.selected[data-value="1"] {
  border-left: 5px solid #28a745;
  background-color: #d1e7dd; /* 淺綠底 */
}
/* 編輯標籤容器樣式 */
.editing-tabs-container {
  display: flex;
  flex-wrap: nowrap;
  overflow-x: auto;
  gap: 5px;
  padding: 10px 5px;
  background-color: #f8f9fa;
  border-bottom: 1px solid #ddd;
  margin-top: 15px;
  scrollbar-width: thin;
  -webkit-overflow-scrolling: touch;
}

/* 隱藏水平滾動條但保持功能 */
.editing-tabs-container::-webkit-scrollbar {
  height: 4px;
}

.editing-tabs-container::-webkit-scrollbar-thumb {
  background-color: rgba(0,0,0,0.2);
  border-radius: 4px;
}

/* 編輯標籤樣式 */
.editing-tab {
  display: flex;
  align-items: center;
  padding: 8px 12px;
  background-color: #e9ecef;
  border-radius: 20px;
  font-size: 14px;
  white-space: nowrap;
  cursor: pointer;
  transition: all 0.2s ease;
  max-width: 150px;
  overflow: hidden;
  flex-shrink: 0;
}

.editing-tab.active {
  background-color: #06c755;
  color: white;
}

.editing-tab .tab-company {
  margin-left: 5px;
  opacity: 0.7;
  font-size: 12px;
}

.editing-tab .tab-close {
  margin-left: 8px;
  width: 18px;
  height: 18px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  background-color: rgba(0,0,0,0.1);
  font-size: 16px;
  line-height: 1;
  transition: all 0.2s ease;
}

.editing-tab.active .tab-close {
  background-color: rgba(255,255,255,0.2);
}

.editing-tab .tab-close:hover {
  background-color: rgba(255,0,0,0.2);
}
.floating-notification {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%) translateY(100px);
  background-color: rgba(0, 0, 0, 0.8);
  color: white;
  padding: 12px 20px;
  border-radius: 8px;
  z-index: 2000;
  transition: transform 0.3s ease;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  text-align: center;
  max-width: 90%;
}
.floating-notification.show {
  transform: translateX(-50%) translateY(0);
}

.floating-notification.success {
  background-color: rgba(6, 199, 85, 0.9);
}

.floating-notification.error {
  background-color: rgba(220, 53, 69, 0.9);
}
.postpone-button {
  background-color: #6c757d;
  color: white;
}

.postpone-button:hover {
  background-color: #5a6268;
  box-shadow: 0 4px 8px rgba(108, 117, 125, 0.2);
}
/* 分類導航樣式 */
.category-nav {
  display: flex;
  gap: 8px;
  overflow-x: auto;
  padding: 5px 0;
  margin-bottom: 8px;
  scrollbar-width: none; /* 隱藏 Firefox 滾動條 */
  -ms-overflow-style: none; /* 隱藏 IE/Edge 滾動條 */
  -webkit-overflow-scrolling: touch; /* 提高滾動流暢度 */
}

.category-nav::-webkit-scrollbar {
  display: none; /* 隱藏 Chrome/Safari 滾動條 */
}

.category-tab {
  padding: 6px 15px;
  background-color: #f8f9fa;
  border: 1px solid #ddd;
  border-radius: 20px;
  font-size: 14px;
  white-space: nowrap;
  cursor: pointer;
  transition: all 0.2s ease;
  flex-shrink: 0; /* 防止標籤被壓縮 */
}

.category-tab.active {
  background-color: #06c755 !important;
  color: white !important;
  border-color: #06c755 !important;
}

/* 滑動容器樣式 */
.swipe-container {
  width: 100%;
  overflow: hidden;
  position: relative;
}

.swipe-wrapper {
  display: flex;
  transition: transform 0.3s ease;
}

.swipe-page {
  min-width: 100%;
  flex-shrink: 0;
}

/* 滑動指示器樣式 */
.swipe-indicators {
  display: flex;
  justify-content: center;
  gap: 6px;
  margin-top: 10px;
}

.swipe-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background-color: #ddd;
  transition: all 0.2s ease;
}

.swipe-dot.active {
  background-color: #06c755;
  transform: scale(1.2);
}

/* 正向和負向項目的樣式 */
.quick-other-item.positive-item {
  border-left: 3px solid #28a745;
}

.quick-other-item.negative-item {
  border-left: 3px solid #dc3545;
}

.quick-other-item.positive-item.selected {
  background-color: #d4edda;
  color: #155724;
  border-color: #28a745;
}
.quick-other-item.positive-item.selected::after {
  background-color: #28a745;
}
.quick-other-item.negative-item.selected {
  background-color: #f8d7da;
  color: #721c24;
  border-color: #dc3545;
}
.quick-other-item.negative-item.selected::after {
  background-color: #dc3545;
}
.category-page {
  width: 100%;
  min-width: auto;
  flex-shrink: 0;
  position: relative;
}
/* 增加觸控區域優化 */
.category-tab, 
.quick-other-item, 
.quick-item {
  touch-action: manipulation;
  -webkit-tap-highlight-color: transparent;
  position: relative;
}
.category-tab::before, 
.quick-other-item::before, 
.quick-item::before {
    pointer-events: auto !important; 
  touch-action: auto !important;
  content: '';
  position: absolute;
  top: -8px;
  left: -8px;
  right: -8px;
  bottom: -8px;
  z-index: 1;
}
/* 確保內容包裹容器正確布局 */
.category-page > div {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  padding: 5px 0;
}
/* 標籤上的項目計數標記樣式 */
.tab-item-count {
  display: inline-block;
  background-color: #06c755;
  color: white;
  border-radius: 50%;
  width: 18px;
  height: 18px;
  font-size: 11px;
  line-height: 18px;
  text-align: center;
  margin-left: 5px;
  font-weight: bold;
}
.editing-tab.active .tab-item-count {
  background-color: rgba(255,255,255,0.3);
}
/* 編輯區車號旁的計數標記樣式 */
#editingItemCountBadge {
  display: inline-block;
  background-color: #06c755;
  color: white;
  border-radius: 50%;
  width: 20px;
  height: 20px;
  font-size: 12px;
  line-height: 20px;
  text-align: center;
  font-weight: bold;
  margin-left: 5px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}
    </style>
  </head>
<body style="overscroll-behavior-y: contain;">
    <!-- 在 body 開始位置添加返回LINE按鈕 -->
    <div id="loading-overlay" class="loading-overlay hidden">
      <div class="spinner"></div>
    </div>

    <div class="container">
      <h2>車輛查核</h2>

      <div id="statusMessage" class="status-message"></div>

      <!-- 即時偵測懸浮顯示 -->
      <div
        id="realTimeDetection"
        class="real-time-detection"
        onclick="showDetectedBuses()"
      >
        <span id="detectionCount" class="detection-count">0</span>
        <span>個新偵測結果</span>
      </div>

      <!-- 位置選擇 -->
      <div class="form-group">
        <label for="location" class="required">我的位置</label>
        <div class="input-group">
          <input type="text" id="location" placeholder="選擇所在位置" />
          <div class="icon-button" onclick="openLocationModal()">
            <i class="fas fa-map-marker-alt"></i>
          </div>
        </div>
      </div>

<div class="utility-buttons">
  <div class="utility-button" onclick="detectBuses()">
    <i class="fas fa-search"></i>
    <span>偵測車輛</span>
  </div>
  <div id="autoDetectButton" class="utility-button" onclick="toggleAutoDetect()">
    <i class="fas fa-sync"></i>
    <span id="autoDetectStatus">自動偵測</span>
  </div>
  <div class="utility-button" onclick="openManualInputModal()">
    <i class="fas fa-plus"></i>
    <span>手動新增</span>
  </div>

</div>
<div class="countdown-container">
  <span id="countdown"></span>
</div>

      <!-- 隱藏欄位 -->
      <input type="hidden" id="positionLat" />
      <input type="hidden" id="userId" />

      <!-- 檢測到的車輛容器 -->
<div id="detectedBusesContainer" class="detected-buses-container">
  <div class="detection-header">
    <div class="detection-title-area">
      <h3>偵測到的車輛：</h3>
      
      <div class="switch-container">
        <!-- <label class="switch">
          <input type="checkbox" id="includeRecordedToggle" onchange="toggleIncludeRecorded()">
          <span class="slider"></span>
        </label>
        <span>顯示3分鐘內已記錄的車輛</span>
      </div> -->
    </div>
    <span id="busCount" class="status-tag status-processing">0 輛</span>
        <div class="direction-legend">
      <span class="direction-tag go-tag">去</span>
      <span class="direction-tag back-tag">返</span>
    </div>
  </div>
  <div id="detectedBusesList">
    <!-- 檢測到的車輛卡片將在這裡動態顯示 -->
    <div class="no-buses-message">
      <i
        class="fas fa-bus"
        style="font-size: 24px; color: #adb5bd; margin-bottom: 10px"
      ></i>
      <p>尚未檢測到車輛，請點擊「偵測車輛」按鈕</p>
    </div>
  </div>
</div>
 <!-- 修改固定的車輛輸入區域結構，調整路線顯示位置 -->
<div id="busInputContainer" class="bus-input-container hidden">
  <div class="bus-info-header">
    <!-- 將路線移到頂部 -->
    <div id="inputBusRoute" class="route-info"></div>
    <div><span id="inputBusCompany" class="company-label"></span> <strong id="inputBusNumber"></strong></div>
  </div>
  
  <div class="input-section">
    <label>重點查核:</label>
    <div id="mainItemsContainer" class="quick-items">
      <!-- 主要項目將在這裡生成 -->
    </div>
    
    <label>其它:</label>
    <div id="otherItemsContainer" class="quick-other-items">
      <!-- 其他項目將在這裡生成 -->
    </div>
    
    <div class="input-actions">
      <div class="action-button submit-button" onclick="submitSelectedBus()">
        <i class="fas fa-check"></i> 送出記錄
      </div>
        <div class="action-button postpone-button" onclick="postponeEditing()">
    <i class="fas fa-clock"></i> 等下編輯
   </div>
      <div class="action-button cancel-button" onclick="cancelBusInput()">
        <i class="fas fa-times"></i> 取消
      </div>
    </div>
  </div>
</div>
<!-- 修改確認對話框模態窗口 -->
<div id="confirmModal" class="modal">
  <div class="modal-content">
    <h3>確認</h3>
    <p id="confirmMessage">是否取消對此車輛的編輯？</p>
    <div class="button-group">
      <button type="button" id="confirmYes">確認</button>
      <button type="button" class="secondary-button" id="confirmNo">取消</button>
    </div>
  </div>
</div>
<!-- 手動輸入車輛模態框 -->
<div id="manualInputModal" class="modal">
  <div class="modal-content">
    <h3>手動新增車輛</h3>
       <div id="manualInputError" class="status-message error" style="display: none; margin-bottom: 15px;"></div>
    <div class="form-group">
      <label for="manualPlateNumber" class="required">車號</label>
      <input type="text" id="manualPlateNumber" placeholder="輸入車號" oninput="convertToUpperCase(this)" onblur="formatPlateNumber(this)">
    </div>
    <div class="form-group">
      <label for="manualCompany">公司</label>
      <select id="manualCompany"  class="required">
        <option value="">請選擇公司</option>
        <option value="首都客運">首都</option>
        <option value="臺北客運">臺北</option>
        <option value="大都會客運">大都會</option>
        <option value="三重客運">三重</option>
        <option value="台中客運">台中</option>
      </select>
    </div>
    <div class="form-group">
      <label for="manualRoute">路線</label>
      <input type="text" id="manualRoute" placeholder="輸入路線">
    </div>
    <div class="form-group">
  <label for="manualDirection">方向</label>
  <div class="direction-buttons">
    <button type="button" class="direction-btn" data-value="0">去程</button>
    <button type="button" class="direction-btn" data-value="1">返程</button>
  </div>
  <input type="hidden" id="manualDirection" value="0">
</div>
    <div class="button-group">
      <button type="button" onclick="addManualBus()">確認新增</button>
      <button type="button" class="secondary-button" onclick="closeManualInputModal()">取消</button>
    </div>
  </div>
</div>
      <div class="line-brand">多功能平台-車輛查核-v1.1.5.5(瀏覽器模式)
        <div style="font-size: 12px; margin-top: 5px;">
    GPS精準度已強化，請確保開啟位置服務
  </div>
      </div>
    </div>

    <!-- 位置選擇彈窗 -->
    <div id="locationModal" class="modal">
      <div class="modal-content">
        <h3>我的位置</h3>
        <!-- 添加重新偵測按鈕 -->
        <div id="detectLocationButtonContainer" class="detect-button-container">
          <button
            id="detectLocationButton"
            type="button"
            class="secondary-button detect-button"
            onclick="refreshLocationList()"
          >
            <i class="fas fa-sync-alt"></i> 路口
          </button>
            <!-- 新增隨車稽查按鈕 -->
      <button
        id="onBoardInspectionButton"
        type="button"
        class="secondary-button detect-button"
        onclick="selectOnBoardInspection()"
      >
        <i class="fas fa-bus"></i> 隨車
      </button>
            <button
        id="detectAddressButton"
        type="button"
        class="secondary-button detect-button"
        onclick="detectAddress()"
      >
        <i class="fas fa-map-marked-alt"></i> 地址
      </button>
        </div>
        <div id="locationList"></div>
        <div class="button-group">
          <button type="button" onclick="closeLocationModal()">關閉</button>
        </div>
      </div>
    </div>


    <!-- 歷史紀錄彈窗 -->
    <div id="historyModal" class="modal">
      <div class="modal-content">
        <h3>今日紀錄</h3>
        <div id="historyList" class="history-list">
          <!-- 歷史紀錄將在這裡動態顯示 -->
        </div>
        <div class="button-group">
          <button type="button" onclick="closeHistoryModal()">關閉</button>
        </div>
      </div>
    </div>
<!-- 添加偵測指示器元素到頁面底部 -->
<div id="detectionIndicator" class="detection-indicator">
  <div class="spinner"></div>
  <span id="detectionMessage">正在偵測車輛...</span>
</div>

 <script>
// 全局變數
const base_url = "https://35.221.146.143.nip.io/linehook/";
const channelId = "2006992891";
let currentLatitude = 0;
let currentLongitude = 0;
let intersections = [];
let allDetectedBuses = []; // 所有偵測到的車輛
let displayedBuses = []; // 目前顯示的車輛
let submittedBuses = []; // 已新增的車輛
let otherItems = [];
let globalLoadingTimeout = null;
let watchId = null;
let isProcessingBus = false;
let startY = 0;
let lastLoadingTime = 0;
// 其他全局變量
let editingBuses = []; // 儲存所有正在編輯中的車輛
let activeEditingBusIndex = -1; // 當前活躍的編輯車輛索引
const MIN_LOADING_INTERVAL = 30000; // 最短loading間隔，毫秒
let lastBackPressTime = 0;
let autoDetectInterval = null;
let countdownInterval = null;
let selectedBus = null; // 保存選中車輛的完整副本
let countdownSeconds = 20; // 預設20秒
let includeRecordedVehicles = false;
let currentSwipePage = 0;
let pagesContainer = null;
let categoryNav = null;
let totalPages = 0;
let backButtonHandlingDelay = false;
// 新增事件管理工具，用於統一管理事件監聽器，避免重複添加和內存洩漏
const EventManager = {
  listeners: {},
  
  // 添加事件監聽器並記錄
  add: function(element, eventType, callback, options) {
    if (!element) return false;
    
    const id = element.id || `elem_${Math.random().toString(36).substr(2, 9)}`;
    if (!element.id) element.id = id;
    
    const key = `${id}_${eventType}`;
    
    // 如果已存在此事件，先移除
    this.remove(element, eventType);
    
    // 添加新事件並記錄
    element.addEventListener(eventType, callback, options);
    this.listeners[key] = {
      element: element,
      callback: callback
    };
    
    return true;
  },
  
  // 移除事件監聽器
  remove: function(element, eventType) {
    if (!element) return false;
    
    const id = element.id;
    if (!id) return false;
    
    const key = `${id}_${eventType}`;
    const listener = this.listeners[key];
    
    if (listener) {
      element.removeEventListener(eventType, listener.callback);
      delete this.listeners[key];
      return true;
    }
    
    return false;
  },
  
  // 清理特定元素的所有事件
  cleanElement: function(element) {
    if (!element || !element.id) return;
    
    const id = element.id;
    
    Object.keys(this.listeners).forEach(key => {
      if (key.startsWith(id + '_')) {
        const eventType = key.split('_')[1];
        this.remove(element, eventType);
      }
    });
  }
};

// 改進的滑動設置函數，使用 EventManager 管理事件
function setupSwipeFeature(container, navBar, totalCategoryPages) {
  pagesContainer = container;
  categoryNav = navBar;
  totalPages = totalCategoryPages;
  currentSwipePage = 0; // 重置為第一頁
  
  if (!pagesContainer || !categoryNav) return;
  
  // 應用初始頁面設置
  updateSwipePageDisplay(0);
  
  // 設置新的事件處理
  let startX, startY;
  let isScrollingVertical = false;
  let initialTarget = null; // 記錄觸摸開始的元素
  
  // 使用 EventManager 添加觸摸開始事件
  EventManager.add(pagesContainer, 'touchstart', function(e) {
    // 記錄初始觸摸的目標元素
    initialTarget = e.target;
    
    // 如果初始觸摸是在項目元素上，則不啟動滑動
    if (initialTarget.closest('.quick-other-item')) {
      startX = null;
      return;
    }
    
    startX = e.touches[0].clientX;
    startY = e.touches[0].clientY;
    isScrollingVertical = false;
    
    // 設置過渡為無，確保觸摸時響應迅速
    pagesContainer.style.transition = 'none';
  }, { passive: true });
  
  // 使用 EventManager 添加觸摸移動事件
  EventManager.add(pagesContainer, 'touchmove', function(e) {
    // 如果沒有啟動滑動或初始觸摸是在項目上，則不處理
    if (!startX || initialTarget.closest('.quick-other-item')) return;
    
    const currentX = e.touches[0].clientX;
    const currentY = e.touches[0].clientY;
    const diffX = startX - currentX;
    const diffY = startY - currentY;
    
    // 設置滑動標記，供其他事件參考
    if (Math.abs(diffX) > 5) {
      window.isSwiping = true;
    }
    
    // 判斷是否垂直滾動
    if (!isScrollingVertical && Math.abs(diffY) > Math.abs(diffX) * 1.2) {
      isScrollingVertical = true;
      return;
    }
    
    // 如果是垂直滾動，不處理水平滑動
    if (isScrollingVertical) return;
    
    // 防止事件冒泡，確保滑動時頁面不會跟著滾動
    e.preventDefault();
    
    // 計算偏移量
    const pageWidth = pagesContainer.offsetWidth;
    const movePercent = (diffX / pageWidth) * 100;
    const currentOffset = -currentSwipePage * 100;
    const newOffset = currentOffset - movePercent;
    
    // 應用新的位置，添加阻尼效果
    let finalOffset = newOffset;
    if (newOffset > 0) {
      finalOffset = newOffset * 0.3; // 左端阻尼
    } else if (newOffset < -(totalPages - 1) * 100) {
      const overScroll = newOffset + (totalPages - 1) * 100;
      finalOffset = -(totalPages - 1) * 100 + overScroll * 0.3; // 右端阻尼
    }
    
    pagesContainer.style.transform = `translateX(${finalOffset}%)`;
  }, { passive: false });
  
  // 使用 EventManager 添加觸摸結束事件
  EventManager.add(pagesContainer, 'touchend', function(e) {
    // 如果沒有啟動滑動或是垂直滾動，不處理
    if (!startX || isScrollingVertical || initialTarget.closest('.quick-other-item')) {
      startX = null;
      startY = null;
      initialTarget = null;
      return;
    }
    
    const currentX = e.changedTouches[0].clientX;
    const diffX = startX - currentX;
    const pageWidth = pagesContainer.offsetWidth;
    
    // 重置起始點
    startX = null;
    startY = null;
    initialTarget = null;
    
    // 恢復過渡效果
    pagesContainer.style.transition = 'transform 0.3s ease';
    
    // 判斷是否需要翻頁
    if (Math.abs(diffX) > pageWidth * 0.15) { // 只需15%的滑動距離
      if (diffX > 0 && currentSwipePage < totalPages - 1) {
        // 向左滑動 -> 下一頁
        updateSwipePageDisplay(currentSwipePage + 1);
      } else if (diffX < 0 && currentSwipePage > 0) {
        // 向右滑動 -> 上一頁
        updateSwipePageDisplay(currentSwipePage - 1);
      } else {
        // 邊界情況：回到當前頁
        updateSwipePageDisplay(currentSwipePage);
      }
    } else {
      // 滑動不夠遠，回到當前頁
      updateSwipePageDisplay(currentSwipePage);
    }
    
    // 延遲重置滑動標記
    setTimeout(() => {
      window.isSwiping = false;
    }, 100);
  }, { passive: true });
  
  // 設置分類標籤點擊事件
  const tabs = categoryNav.querySelectorAll('.category-tab');
  tabs.forEach((tab, index) => {
    // 清理舊事件並添加新事件
    EventManager.cleanElement(tab);
    EventManager.add(tab, 'click', function() {
      updateSwipePageDisplay(index);
    });
  });
}
// 車輛數據管理模塊，統一管理車輛數據，避免狀態不一致
const BusManager = {
  allDetectedBuses: [], // 全局車輛列表
  displayedBuses: [],   // 顯示的車輛列表
  editingBuses: [],     // 編輯中的車輛列表
  submittedBuses: [],   // 已提交的車輛列表
  activeEditingBusIndex: -1, // 當前編輯的車輛索引
  
  // 初始化模塊
  init: function() {
    // 從全局變量複製數據
    this.allDetectedBuses = [...allDetectedBuses];
    this.displayedBuses = [...displayedBuses];
    this.editingBuses = [...editingBuses];
    this.submittedBuses = [...submittedBuses];
    this.activeEditingBusIndex = activeEditingBusIndex;
    
    return this;
  },
  
  // 同步模塊數據到全局變量
  syncToGlobal: function() {
    allDetectedBuses = [...this.allDetectedBuses];
    displayedBuses = [...this.displayedBuses];
    editingBuses = [...this.editingBuses];
    submittedBuses = [...this.submittedBuses];
    activeEditingBusIndex = this.activeEditingBusIndex;
    
    return this;
  },
  
  // 添加新車輛，確保唯一ID和不重複
  addBus: function(bus) {
    if (!bus) return false;
    
    // 確保有唯一ID
    if (!bus.uniqueId) {
      bus.uniqueId = uuid.v4();
    }
    
    // 添加時間戳
    bus.lastUpdated = Date.now();
    
    // 檢查是否已存在相同ID的車輛
    const existInAll = this.allDetectedBuses.some(item => item.uniqueId === bus.uniqueId);
    
    if (!existInAll) {
      this.allDetectedBuses.push(bus);
    } else {
      // 如果已存在，更新而不是添加
      this.updateBus(bus.uniqueId, bus);
    }
    
    // 檢查是否應該添加到顯示列表
    const existInDisplay = this.displayedBuses.some(item => item.uniqueId === bus.uniqueId);
    
    if (!existInDisplay && !this.isRecentlySubmitted(bus.plateNumber)) {
      this.displayedBuses.push(bus);
    }
    
    // 同步到全局變量
    this.syncToGlobal();
    
    return true;
  },
  
  // 根據唯一ID更新車輛
  updateBus: function(uniqueId, updateData) {
    if (!uniqueId || !updateData) return false;
    
    let updated = false;
    
    // 更新全局列表
    const globalIndex = this.allDetectedBuses.findIndex(item => item.uniqueId === uniqueId);
    if (globalIndex !== -1) {
      this.allDetectedBuses[globalIndex] = {
        ...this.allDetectedBuses[globalIndex],
        ...updateData,
        lastUpdated: Date.now()
      };
      updated = true;
    }
    
    // 更新顯示列表
    const displayIndex = this.displayedBuses.findIndex(item => item.uniqueId === uniqueId);
    if (displayIndex !== -1) {
      this.displayedBuses[displayIndex] = {
        ...this.displayedBuses[displayIndex],
        ...updateData,
        lastUpdated: Date.now()
      };
      updated = true;
    }
    
    // 更新編輯列表
    const editIndex = this.editingBuses.findIndex(item => item.uniqueId === uniqueId);
    if (editIndex !== -1) {
      this.editingBuses[editIndex] = {
        ...this.editingBuses[editIndex],
        ...updateData,
        lastUpdated: Date.now()
      };
      
      // 如果更新的是當前編輯中的車輛，可能需要更新UI
      if (editIndex === this.activeEditingBusIndex) {
        // 這裡僅標記需要更新，實際UI更新在調用處處理
      }
      
      updated = true;
    }
    
    if (updated) {
      // 同步到全局變量
      this.syncToGlobal();
    }
    
    return updated;
  },
  
  // 添加車輛到編輯列表
  addToEditing: function(bus, originalIndex) {
    if (!bus) return false;
    
    // 確保有唯一ID
    if (!bus.uniqueId) {
      bus.uniqueId = uuid.v4();
    }
    
    // 檢查是否已在編輯列表中
    const existingIndex = this.editingBuses.findIndex(item => item.uniqueId === bus.uniqueId);
    
    if (existingIndex !== -1) {
      // 已在編輯列表中，更新索引並設置為活躍
      this.activeEditingBusIndex = existingIndex;
    } else {
      // 創建編輯副本
      const editCopy = JSON.parse(JSON.stringify(bus));
      editCopy.selectedOtherItems = editCopy.selectedOtherItems || [];
      editCopy.originalPlateNumber = bus.plateNumber;
      editCopy.originalIndex = originalIndex;
      
      // 添加到編輯列表
      this.editingBuses.push(editCopy);
      this.activeEditingBusIndex = this.editingBuses.length - 1;
      
      // 標記為編輯中
      this.markAsEditing(bus.uniqueId);
    }
    
    // 同步到全局變量
    this.syncToGlobal();
    
    return true;
  },
  
  // 標記車輛為編輯中
  markAsEditing: function(uniqueId) {
    // 更新全局列表和顯示列表中的編輯狀態
    this.allDetectedBuses.forEach(bus => {
      if (bus.uniqueId === uniqueId) {
        bus.isInEditing = true;
      }
    });
    
    this.displayedBuses.forEach(bus => {
      if (bus.uniqueId === uniqueId) {
        bus.isInEditing = true;
      }
    });
    
    // 同步到全局變量
    this.syncToGlobal();
  },
  
  // 從編輯列表移除車輛
  removeFromEditing: function(index) {
    if (index < 0 || index >= this.editingBuses.length) return false;
    
    // 保存要移除的車輛信息
    const removedBus = this.editingBuses[index];
    
    // 移除編輯標記
    if (removedBus && removedBus.uniqueId) {
      this.allDetectedBuses.forEach(bus => {
        if (bus.uniqueId === removedBus.uniqueId) {
          bus.isInEditing = false;
        }
      });
      
      this.displayedBuses.forEach(bus => {
        if (bus.uniqueId === removedBus.uniqueId) {
          bus.isInEditing = false;
        }
      });
    }
    
    // 從編輯列表移除
    this.editingBuses.splice(index, 1);
    
    // 調整活躍索引
    if (this.editingBuses.length === 0) {
      this.activeEditingBusIndex = -1;
    } else if (this.activeEditingBusIndex >= this.editingBuses.length) {
      this.activeEditingBusIndex = this.editingBuses.length - 1;
    } else if (this.activeEditingBusIndex === index) {
      this.activeEditingBusIndex = 0;
    }
    
    // 同步到全局變量
    this.syncToGlobal();
    
    return true;
  },
  
  // 檢查車輛是否最近已提交
  isRecentlySubmitted: function(plateNumber) {
    const submissionTime = localStorage.getItem(`submitted_${plateNumber}`);
    if (!submissionTime) return false;
    
    const SUBMISSION_EXPIRY_TIME_MS = 2 * 60 * 1000; // 2分鐘
    return (Date.now() - parseInt(submissionTime)) < SUBMISSION_EXPIRY_TIME_MS;
  },
  
  // 同步所有列表中的編輯狀態
  syncEditingStatus: function() {
    // 創建唯一ID集合
    const editingIds = new Set(this.editingBuses.map(bus => bus.uniqueId));
    
    // 更新顯示列表
    this.displayedBuses.forEach(bus => {
      bus.isInEditing = editingIds.has(bus.uniqueId);
    });
    
    // 更新全局列表
    this.allDetectedBuses.forEach(bus => {
      bus.isInEditing = editingIds.has(bus.uniqueId);
    });
    
    // 同步到全局變量
    this.syncToGlobal();
  },
  
  // 檢測和處理車牌重複問題
  detectAndResolveDuplicates: function() {
    // 檢查顯示列表中是否有車牌重複
    const plateMap = new Map();
    const duplicatePlates = new Set();
    
    // 第一遍掃描，找出重複車牌
    this.displayedBuses.forEach(bus => {
      if (plateMap.has(bus.plateNumber)) {
        duplicatePlates.add(bus.plateNumber);
      } else {
        plateMap.set(bus.plateNumber, bus);
      }
    });
    
    // 如果有重複車牌，進行處理
    if (duplicatePlates.size > 0) {
      console.log(`檢測到 ${duplicatePlates.size} 個重複車牌:`, Array.from(duplicatePlates));
      
      // 對每個重複車牌，保留最新更新的一個
      duplicatePlates.forEach(plateNumber => {
        // 收集所有該車牌的車輛
        const buses = this.displayedBuses.filter(bus => bus.plateNumber === plateNumber);
        
        // 按最後更新時間排序，保留最新的一個
        buses.sort((a, b) => (b.lastUpdated || 0) - (a.lastUpdated || 0));
        
        // 保留最新更新的車輛
        const keepBus = buses[0];
        
        // 從顯示列表和全局列表中移除其餘重複項
        for (let i = 1; i < buses.length; i++) {
          const removeBus = buses[i];
          
          this.displayedBuses = this.displayedBuses.filter(bus => bus.uniqueId !== removeBus.uniqueId);
          this.allDetectedBuses = this.allDetectedBuses.filter(bus => bus.uniqueId !== removeBus.uniqueId);
          
          console.log(`移除重複車牌 ${plateNumber} 的車輛, ID: ${removeBus.uniqueId}`);
        }
      });
      
      // 同步到全局變量
      this.syncToGlobal();
      
      return true;
    }
    
    return false;
  }
};
// 改進的位置獲取函數，提供更多的錯誤處理和位置源信息
async function getCurrentPosition(silent = false) {
  showLoading();
  console.log("開始獲取高精度位置...");
  
  let retryCount = 0;
  const maxRetries = 3;
  let locationSource = "即時GPS"; // 標記位置來源

  try {
    while (retryCount < maxRetries && navigator.geolocation) {
      try {
        // 清除之前的位置監視
        if (window.watchId) {
          navigator.geolocation.clearWatch(window.watchId);
          window.watchId = null;
        }
        
        const position = await new Promise((resolve, reject) => {
          navigator.geolocation.getCurrentPosition(resolve, reject, {
            enableHighAccuracy: true,
            timeout: 20000,
            maximumAge: 0
          });
        });

        console.log("高精度位置獲取成功");
        currentLatitude = position.coords.latitude;
        currentLongitude = position.coords.longitude;
        savePosition(currentLatitude, currentLongitude);
        
        // 更新位置精度指示器
        updateLocationAccuracyIndicator(position.coords.accuracy, locationSource);
        
        // 重新啟動位置監視
        startHighAccuracyLocationWatching(true);
        
        hideLoading();
        return {
          success: true,
          source: locationSource,
          accuracy: position.coords.accuracy
        };
      } catch (geoError) {
        console.error("位置API錯誤:", geoError.code, geoError.message);
        retryCount++;
        
        if (retryCount < maxRetries) {
          console.log(`位置獲取失敗，進行第${retryCount}次重試`);
          await new Promise(resolve => setTimeout(resolve, 3000));
        } else {
          console.log("達到最大重試次數");
          break;
        }
      }
    }

    // 嘗試使用本地緩存位置
    if (loadLastPosition()) {
      console.log("使用本地緩存位置作為後備");
      locationSource = "緩存位置";
      
      // 更新位置精度指示器
      updateLocationAccuracyIndicator(100, locationSource); // 假設緩存位置精度為100米
      
      hideLoading();
      return {
        success: true,
        source: locationSource,
        accuracy: 100 // 估計精度
      };
    }
    
    // 使用默認位置作為最後後備
    console.log("使用預設位置作為後備");
    locationSource = "預設位置";
    currentLatitude = 25.033; // 台北市中心位置
    currentLongitude = 121.565;
    savePosition(currentLatitude, currentLongitude);
    
    // 更新位置精度指示器為最低精度
    updateLocationAccuracyIndicator(999, locationSource);
    
    hideLoading();

    if (!silent) {
      showStatusMessage("無法準確獲取位置，使用預設位置", "warning", true);
    }
    return {
      success: true,
      source: locationSource,
      accuracy: 999
    };
  } catch (error) {
    console.error("位置獲取完全失敗:", error);
    hideLoading();
    
    // 更新位置精度指示器為出錯狀態
    updateLocationAccuracyIndicator(999, "錯誤");
    
    if (!silent) {
      showStatusMessage("無法獲取位置，請開啟位置權限或至室外", "error", true);
    }
    return {
      success: false,
      source: "錯誤",
      error: error.message
    };
  }
}
// 改進的位置精度指示器，顯示位置來源信息
function updateLocationAccuracyIndicator(accuracy, source = "GPS") {
  const accuracyElement = document.querySelector(".location-accuracy");
  if (!accuracyElement) return;
  
  if (accuracy === 999) {
    accuracyElement.innerHTML = `<i class="fas fa-exclamation-triangle" style="color:red;"></i> 無法獲取精確位置 (${source})`;
    return;
  }
  
  let color, text;
  if (accuracy < 10) {
    color = "green";
    text = "高";
  } else if (accuracy < 50) {
    color = "orange";
    text = "中";
  } else {
    color = "red";
    text = "低";
  }
  
  // 顯示位置來源
  const sourceText = source === "即時GPS" ? "" : ` - ${source}`;
  accuracyElement.innerHTML = `<i class="fas fa-crosshairs" style="color:${color};"></i> 位置精確度${text} (${Math.round(accuracy)}m${sourceText})`;
}

// 改進的車輛偵測函數，更好的錯誤處理和用戶反饋
async function detectBuses(isAutoDetection = false) {
  // 顯示偵測指示器
  const indicatorMsg = isAutoDetection ? "自動偵測中..." : "正在偵測車輛...";
  showDetectionIndicator(indicatorMsg);
  
  try {
    // 獲取最新位置
    const positionResult = await forceUpdatePosition(isAutoDetection);
    if (!positionResult) {
      hideDetectionIndicator();
      if (!isAutoDetection) {
        showStatusMessage("無法獲取位置，偵測已取消", "error", true);
      }
      return;
    }

    // 保存當前編輯中的車輛的唯一ID和車牌號
    const editingBusIds = new Set(editingBuses.map(bus => bus.uniqueId));
    const editingPlateNumbers = new Set(editingBuses.map(bus => bus.plateNumber));

    // 清空全局列表，但保留編輯中的車輛
    allDetectedBuses = allDetectedBuses.filter(bus => 
      editingBusIds.has(bus.uniqueId) || editingPlateNumbers.has(bus.plateNumber)
    );
    
    displayedBuses = displayedBuses.filter(bus => 
      editingBusIds.has(bus.uniqueId) || editingPlateNumbers.has(bus.plateNumber)
    );

    // 獲取附近車輛
    const response = await fetchWithRetry(
      `${base_url}monitor/buses?latitude=${currentLatitude}&longitude=${currentLongitude}&distance=300`,
      {},
      3
    );
    
    if (!response.ok) {
      throw new Error(`HTTP 錯誤 ${response.status}`);
    }
    
    const data = await response.json();
    const newDetectedBuses = [];
    
    // 用來追蹤已處理的車牌，避免重複
    const processedPlates = new Set();
    
    if (data && data.buses && data.buses.length > 0) {
      data.buses.forEach((bus) => {
        // 如果車輛沒有唯一ID，生成一個
        if (!bus.uniqueId) {
          bus.uniqueId = uuid.v4();
        }
        
        // 新增檢查：車牌是否已經在本次處理中
        if (processedPlates.has(bus.plateNumber)) {
          console.log(`跳過本次偵測中重複的車牌: ${bus.plateNumber}`);
          return; // 跳過重複車牌
        }
        
        // 檢查此車牌是否在規定時間內已經提交過
        if (isRecentlySubmitted(bus.plateNumber)) {
          console.log(`跳過最近已提交的車輛: ${bus.plateNumber}`);
          return; // 跳過最近已提交的車輛
        }
        
        // 標記此車牌已處理
        processedPlates.add(bus.plateNumber);
        
        // 檢查這輛車是否已在編輯列表中(根據車牌號和唯一ID)
        const isInEditing = editingBusIds.has(bus.uniqueId) || editingPlateNumbers.has(bus.plateNumber);
        
        // 如果在編輯列表中，僅更新位置數據
        if (isInEditing) {
          // 找到對應的編輯中車輛
          let editingBusIndex = -1;
          
          // 先嘗試通過唯一ID找到
          editingBusIndex = editingBuses.findIndex(item => item.uniqueId === bus.uniqueId);
          
          // 如果通過ID沒找到，嘗試通過車牌號找到
          if (editingBusIndex === -1) {
            editingBusIndex = editingBuses.findIndex(item => item.plateNumber === bus.plateNumber);
          }
          
          if (editingBusIndex !== -1) {
            // 更新編輯中車輛的位置信息
            editingBuses[editingBusIndex].position = bus.position;
            // 確保唯一ID一致（如果通過車牌找到的）
            if (editingBuses[editingBusIndex].uniqueId !== bus.uniqueId) {
              bus.uniqueId = editingBuses[editingBusIndex].uniqueId;
            }
          }
          
          // 標記為已在編輯中
          bus.isInEditing = true;
        }
        
        // 檢查是否是集團公司
        if (isGroupCompany(bus.operatorName)) {
          // 檢查是否已存在相同車牌號的車輛（在全局列表中）
          const existingBusIndex = allDetectedBuses.findIndex(item => 
            item.plateNumber === bus.plateNumber);
          
          if (existingBusIndex === -1) {
            // 不存在，添加到全局列表
            bus.lastUpdated = Date.now(); // 添加最後更新時間戳
            allDetectedBuses.push(bus);
            
            // 如果車輛不在規定時間內已提交列表中，添加到顯示列表
            if (!isRecentlySubmitted(bus.plateNumber)) {
              // 檢查是否已存在於顯示列表(使用車牌號檢查)
              const existsInDisplay = displayedBuses.some(item => item.plateNumber === bus.plateNumber);
              
              if (!existsInDisplay) {
                displayedBuses.push(bus);
                
                // 只有不在編輯列表中的車輛才算作新偵測結果
                if (!isInEditing) {
                  newDetectedBuses.push(bus);
                }
              }
            }
          } else {
            // 已存在，更新位置等信息
            const existingBus = allDetectedBuses[existingBusIndex];
            allDetectedBuses[existingBusIndex] = {
              ...existingBus,
              position: bus.position,
              lastUpdated: Date.now(),
              // 確保保留原有的唯一ID
              uniqueId: existingBus.uniqueId || bus.uniqueId
            };
            
            // 如果也在顯示列表中，更新顯示列表中的數據
            const displayIndex = displayedBuses.findIndex(item => item.plateNumber === bus.plateNumber);
            if (displayIndex !== -1) {
              displayedBuses[displayIndex] = {
                ...displayedBuses[displayIndex],
                position: bus.position,
                lastUpdated: Date.now()
              };
            }
          }
        }
      });
    }
    
    // 確保所有編輯中的車輛都在顯示列表中
    editingBuses.forEach(editingBus => {
      // 檢查這輛車是否已經在顯示列表中(使用車牌和唯一ID檢查)
      const displayIndex = displayedBuses.findIndex(item => 
        item.uniqueId === editingBus.uniqueId || item.plateNumber === editingBus.plateNumber
      );
      
      // 如果不在顯示列表中，添加進去
      if (displayIndex === -1) {
        // 標記為已在編輯中
        editingBus.isInEditing = true;
        
        // 添加到顯示列表
        displayedBuses.push(editingBus);
        
        // 如果也不在全局列表中，添加進去
        const globalIndex = allDetectedBuses.findIndex(item => 
          item.uniqueId === editingBus.uniqueId || item.plateNumber === editingBus.plateNumber
        );
        if (globalIndex === -1) {
          allDetectedBuses.push(editingBus);
        }
      } else {
        // 確保顯示列表中的車輛標記為編輯中
        displayedBuses[displayIndex].isInEditing = true;
      }
    });
    
    // 檢測和處理車牌重複問題
    detectAndResolvePlateDuplicates();
    
    // 再次過濾最近提交的車輛
    filterRecentlySubmittedBuses();
    
    // 更新UI
    updateDetectedBusesList();
    
    // 顯示通知
    if (newDetectedBuses.length > 0) {
      showNewDetectionNotification(newDetectedBuses.length);
    } else if (!isAutoDetection) {
      showZeroDetectionNotification();
    }
    
    hideDetectionIndicator();
  } catch (error) {
    console.error("偵測車輛失敗:", error);
    hideDetectionIndicator();
    
    if (!isAutoDetection) {
      showStatusMessage(`偵測車輛失敗: ${error.message || "未知錯誤"}，請稍後再試`, "error", true);
    }
  }
  
  if (!isAutoDetection) {
    logVehicleState("偵測車輛完成");
  }
  
  // 同步編輯狀態
  syncEditingStatus();
}
// 強制更新位置函數，更好的錯誤處理和位置回退機制
async function forceUpdatePosition(silent = false) {
  console.log("強制更新位置...");
  
  try {
    // 清除之前的位置監視，避免衝突
    if (window.watchId) {
      navigator.geolocation.clearWatch(window.watchId);
      window.watchId = null;
    }
    
    // 直接向瀏覽器請求高精度位置
    const position = await new Promise((resolve, reject) => {
      const timeoutId = setTimeout(() => {
        reject(new Error("獲取位置超時"));
      }, 15000); // 15秒超時
      
      navigator.geolocation.getCurrentPosition(
        (pos) => {
          clearTimeout(timeoutId);
          resolve(pos);
        }, 
        (err) => {
          clearTimeout(timeoutId);
          reject(err);
        }, 
        {
          enableHighAccuracy: true,
          timeout: 15000,
          maximumAge: 0
        }
      );
    });
    
    console.log("成功獲取新位置");
    currentLatitude = position.coords.latitude;
    currentLongitude = position.coords.longitude;
    savePosition(currentLatitude, currentLongitude);
    
    // 更新位置精度指示器
    updateLocationAccuracyIndicator(position.coords.accuracy, "即時GPS");
    
    // 重新啟動位置監視
    startHighAccuracyLocationWatching(true);
    
    return true;
  } catch (error) {
    console.error("強制更新位置失敗:", error);
    
    // 嘗試使用本地緩存作為後備
    if (loadLastPosition()) {
      // 只使用最近10秒內的緩存位置
      if (Date.now() - safeStorage.get("lastPositionTimestamp") < 10000) {
        if (!silent) {
          showStatusMessage("使用最近位置作為後備", "info", true);
        }
        
        // 更新位置精度指示器，使用較低的精度值表示這是緩存位置
        updateLocationAccuracyIndicator(100, "緩存位置");
        
        return true;
      }
    }
    
    if (!silent) {
      showStatusMessage("無法獲取位置，請確認位置權限並在室外使用", "error", true);
    }
    
    // 更新位置精度指示器為錯誤狀態
    updateLocationAccuracyIndicator(999, "錯誤");
    
    return false;
  }
}
// 使用DocumentFragment優化更新車輛列表
function updateDetectedBusesList() {
  // 獲取容器元素
  const container = document.getElementById("detectedBusesList");
  if (!container) return;
  
  // 記錄函數開始時間，用於性能測量
  const startTime = performance.now();
  
  // 更新計數
  const busCountElement = document.getElementById("busCount");
  if (busCountElement) {
    busCountElement.textContent = `${displayedBuses.length} 輛`;
  }
  
  // 使用 DocumentFragment 減少 DOM 操作次數
  const fragment = document.createDocumentFragment();
  
  if (displayedBuses.length === 0) {
    // 沒有車輛時顯示提示信息
    const noDataMessage = document.createElement("div");
    noDataMessage.className = "no-buses-message";
    noDataMessage.innerHTML = `
      <i class="fas fa-bus" style="font-size: 24px; color: #adb5bd; margin-bottom: 10px;"></i>
      <p>尚未檢測到車輛，請點擊「偵測車輛」按鈕</p>
    `;
    fragment.appendChild(noDataMessage);
  } else {
    // 創建新的車輛列表容器
    const busListContainer = document.createElement("div");
    busListContainer.className = "simple-bus-list";
    
    // 收集已在編輯中的車輛 ID，避免重複查詢
    const editingBusIds = new Set(editingBuses.map(bus => bus.uniqueId));
    
    // 使用虛擬列表技術處理顯示 - 首先只渲染可見的元素
    const batchSize = 20;
    const firstBatchEnd = Math.min(batchSize, displayedBuses.length);
    
    // 使用 WeakMap 緩存車輛距離計算結果，避免重複計算
    const distanceCache = new WeakMap();
    
    // 先渲染第一批可見的車輛
    for (let i = 0; i < firstBatchEnd; i++) {
      const bus = displayedBuses[i];
      
      // 緩存車輛是否在編輯中的狀態
      bus.isEditing = editingBusIds.has(bus.uniqueId);
      
      // 緩存車輛距離計算
      if (!distanceCache.has(bus)) {
        distanceCache.set(bus, getVehicleDistance(bus));
      }
      
      const busItem = createBusListItem(bus, i, distanceCache.get(bus));
      busListContainer.appendChild(busItem);
    }
    
    // 如果有更多車輛，使用 requestIdleCallback 或 setTimeout 延遲加載
    if (displayedBuses.length > batchSize) {
      const loadRemainingItems = () => {
        // 分批次加載剩餘車輛，每次加載一小批
        const startIdx = firstBatchEnd;
        const endIdx = displayedBuses.length;
        let currentIdx = startIdx;
        
        const loadNextBatch = () => {
          if (currentIdx >= endIdx) {
            // 所有批次加載完成，初始化跑馬燈
            setTimeout(debouncedInitMarquees, 100);
            return;
          }
          
          // 加載下一批
          const batchEndIdx = Math.min(currentIdx + batchSize, endIdx);
          
          // 使用 DocumentFragment 批量添加元素
          const batchFragment = document.createDocumentFragment();
          
          for (let i = currentIdx; i < batchEndIdx; i++) {
            const bus = displayedBuses[i];
            bus.isEditing = editingBusIds.has(bus.uniqueId);
            
            // 使用緩存的距離
            if (!distanceCache.has(bus)) {
              distanceCache.set(bus, getVehicleDistance(bus));
            }
            
            const busItem = createBusListItem(bus, i, distanceCache.get(bus));
            batchFragment.appendChild(busItem);
          }
          
          // 一次性添加到DOM
          busListContainer.appendChild(batchFragment);
          
          // 更新索引
          currentIdx = batchEndIdx;
          
          // 如果瀏覽器支持 requestIdleCallback，使用它來調度下一批加載
          if (window.requestIdleCallback) {
            window.requestIdleCallback(loadNextBatch);
          } else {
            setTimeout(loadNextBatch, 50);
          }
        };
        
        // 開始加載第一批
        if (window.requestIdleCallback) {
          window.requestIdleCallback(loadNextBatch);
        } else {
          setTimeout(loadNextBatch, 50);
        }
      };
      
      // 延遲加載剩餘項目
      setTimeout(loadRemainingItems, 100);
    } else {
      // 如果車輛數量少，直接初始化跑馬燈
      setTimeout(debouncedInitMarquees, 100);
    }
    
    fragment.appendChild(busListContainer);
  }
  
  // 檢測是否真的需要更新 DOM
  // 比較新舊內容的車輛數量，只有在不同時才更新
  const oldBusCount = container.querySelectorAll('.simple-bus-item').length;
  const newBusCount = displayedBuses.length;
  
  // 只有在車輛數量變化或強制更新時才替換整個內容
  if (oldBusCount !== newBusCount || container.querySelector('.no-buses-message')) {
    // 清空容器並一次性添加所有新元素
    container.innerHTML = "";
    container.appendChild(fragment);
  }
  
  // 記錄函數執行時間
  const endTime = performance.now();
  console.log(`更新車輛列表耗時: ${(endTime - startTime).toFixed(2)}ms，共 ${displayedBuses.length} 輛車`);
  
  // 觸發事件，通知其他組件更新完成
  const updateEvent = new CustomEvent('busListUpdated', { 
    detail: { count: displayedBuses.length } 
  });
  document.dispatchEvent(updateEvent);
  
  // 同步編輯狀態
  syncEditingStatus();
}
// 改進的車輛列表項創建函數，支持緩存距離和優化性能
function createBusListItem(bus, index, cachedDistance = null) {
  // 確保車輛有唯一ID和索引信息
  if (!bus.uniqueId) {
    bus.uniqueId = uuid.v4();
    // 更新全局列表中的對應車輛ID
    const globalBus = allDetectedBuses.find(b => 
      b.plateNumber === bus.plateNumber && 
      b.operatorName === bus.operatorName && 
      !b.uniqueId
    );
    if (globalBus) {
      globalBus.uniqueId = bus.uniqueId;
    }
  }
    
  // 存儲原始索引用於後續更新
  bus.originalIndex = index;
  
  // 路線信息
  const routeInfo = bus.routeName?.chinese || "未知路線";
  
  const busItem = document.createElement("div");
  busItem.className = "simple-bus-item";
  busItem.dataset.index = index;
  busItem.dataset.id = bus.uniqueId;

  // 修改編輯狀態判斷，只使用唯一ID精確匹配
  const isEditing = bus.isEditing || editingBuses.some(editingBus => 
    editingBus.uniqueId === bus.uniqueId
  );
  
  if (isEditing) {
    busItem.classList.add("selected-bus-item");
  }
  
  // 創建路線元素包裹容器
  const routeElement = document.createElement("div");
  routeElement.className = "bus-route-container";
  
  // 使用跑馬燈包裝路線文字
  const routeTextElement = document.createElement("div");
  routeTextElement.className = "text-marquee";
  
  // 如果中文字符數量超過5個，或總長度超過12個字符，則啟用跑馬燈
  if (countChineseChars(routeInfo) > 5 || routeInfo.length > 12) {
    routeTextElement.classList.add("list-marquee", "scrolling");
    // 重複文本以避免空白間隔，使用「　」（全角空格）作為分隔
    const repeatedText = routeInfo + "　" + routeInfo;
    routeTextElement.textContent = repeatedText;
    // 設置動畫持續時間
    routeTextElement.style.setProperty('--scroll-duration', `${Math.min(20, Math.max(10, routeInfo.length * 0.7))}s`);
  } else {
    // 短路線名稱直接顯示，不使用跑馬燈
    routeTextElement.textContent = routeInfo;
  }
  
  // 添加title屬性，以便鼠標懸停時顯示完整路線
  routeElement.title = routeInfo;
  
  routeElement.appendChild(routeTextElement);
  
  // 創建車號元素
  const plateElement = document.createElement("div");
  plateElement.className = "bus-plate";
  
  // 獲取距離並設置對應的CSS類
  const distanceInMeters = cachedDistance !== null ? cachedDistance : getVehicleDistance(bus);
  
  // 使用函數添加對應的距離類
  addDistanceClassToElement(plateElement, distanceInMeters);
  
  // 添加方向樣式類
  if (bus.direction === "0") {
    plateElement.classList.add("direction-go");
  } else if (bus.direction === "1") {
    plateElement.classList.add("direction-back");
  }

  plateElement.textContent = bus.plateNumber;
  
  // 將元素添加到車輛項目中
  busItem.appendChild(routeElement);
  busItem.appendChild(plateElement);
  
  // 使用事件委托而非直接綁定事件
  busItem.dataset.plateNumber = bus.plateNumber;
  
  // 添加數據屬性，便於事件委托時識別
  busItem.dataset.busIndex = index;
  
  return busItem;
}
// 改進的跑馬燈初始化函數，使用 IntersectionObserver 只處理可見元素
function initializeMarquees() {
  // 檢查是否已經初始化過 IntersectionObserver
  if (!window.marqueeObserver) {
    // 創建觀察器
    window.marqueeObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        const marquee = entry.target;
        
        // 只處理可見的元素
        if (entry.isIntersecting) {
          processMarquee(marquee);
        } else {
          // 不可見時暫停動畫
          marquee.classList.remove('scrolling');
        }
      });
    }, {
      root: null,
      rootMargin: '0px',
      threshold: 0.1 // 只需要10%可見即可觸發
    });
  }
  
  // 獲取所有需要處理的跑馬燈元素
  const marquees = document.querySelectorAll('.text-marquee');
  
  // 如果沒有元素，直接返回
  if (marquees.length === 0) return;
  
  // 添加所有元素到觀察器
  marquees.forEach(marquee => {
    // 先從觀察器中移除（避免重複添加）
    window.marqueeObserver.unobserve(marquee);
    
    // 重新添加到觀察器
    window.marqueeObserver.observe(marquee);
  });
}

// 處理單個跑馬燈元素
function processMarquee(marquee) {
  // 檢查元素是否可見且已渲染
  if (!isElementVisible(marquee)) return;
  
  // 獲取父元素和文本寬度
  const parentWidth = marquee.parentElement.offsetWidth;
  const textWidth = marquee.scrollWidth;
  
  // 只有當文本超出容器寬度時才設置滾動
  if (textWidth > parentWidth) {
    // 移除現有動畫類以重置
    marquee.classList.remove('scrolling');
    
    // 計算適當的動畫持續時間
    const textLength = marquee.textContent.length;
    const CHARACTER_SCROLL_SPEED = 0.7;
    const MIN_DURATION = 8;
    const MAX_DURATION = 20;
    
    let duration = textLength * CHARACTER_SCROLL_SPEED;
    duration = Math.max(MIN_DURATION, Math.min(MAX_DURATION, duration));
    
    // 設置動畫持續時間變量
    marquee.style.setProperty('--scroll-duration', `${duration}s`);
    
    // 強制重排
    void marquee.offsetWidth;
    
    // 重新添加動畫類
    marquee.classList.add('scrolling');
    
    // 特別處理列表跑馬燈
    if (marquee.classList.contains('list-marquee')) {
      // 優化列表項動畫速度
      let listDuration = duration * 0.7;
      marquee.style.setProperty('--scroll-duration', `${listDuration}s`);
    }
  } else {
    // 內容未超出，不需要滾動
    marquee.classList.remove('scrolling');
  }
}
// 使用事件委派替代多個個別事件，提高性能
function setupEventDelegation() {
  // 車輛列表的事件委派
  const busList = document.getElementById("detectedBusesList");
  
  // 移除現有事件監聽器（如果有）
  EventManager.cleanElement(busList);
  
  // 添加新的事件監聽器
  EventManager.add(busList, "click", function(e) {
    // 找到最近的 bus-item 元素
    const busItem = e.target.closest(".simple-bus-item");
    if (!busItem) return;
    
    const index = parseInt(busItem.dataset.index, 10);
    if (isNaN(index) || index < 0 || index >= displayedBuses.length) return;
    
    // 防止過快點擊
    if (busItem.dataset.processing === "true") return;
    busItem.dataset.processing = "true";
    
    // 使用防抖處理點擊
    setTimeout(() => {
      // 處理單擊事件
      selectBusForInput(displayedBuses[index], index, false);
      
      // 重置處理狀態
      setTimeout(() => {
        busItem.dataset.processing = "false";
      }, 300);
    }, 10);
  });
  
  // 為雙擊事件添加另一個監聽器
  EventManager.add(busList, "dblclick", function(e) {
    const busItem = e.target.closest(".simple-bus-item");
    if (!busItem) return;
    
    const index = parseInt(busItem.dataset.index, 10);
    if (isNaN(index) || index < 0 || index >= displayedBuses.length) return;
    
    // 雙擊時清除單擊的延遲處理
    clearTimeout(busItem._singleClickTimer);
    
    // 處理雙擊：添加到待編輯並滾動到編輯區
    selectBusForInput(displayedBuses[index], index, true);
  });
  
  // 主項目容器的事件委派
  const mainItemsContainer = document.getElementById("mainItemsContainer");
  if (mainItemsContainer) {
    EventManager.cleanElement(mainItemsContainer);
    EventManager.add(mainItemsContainer, "click", function(e) {
      const item = e.target.closest(".quick-item");
      if (!item) return;
      
      // 清除所有選中狀態
      mainItemsContainer.querySelectorAll(".quick-item").forEach(el => {
        el.classList.remove("selected");
      });
      
      // 設置當前項為選中
      item.classList.add("selected");
      
      // 儲存選擇到當前編輯的車輛對象
      if (activeEditingBusIndex >= 0 && activeEditingBusIndex < editingBuses.length) {
        editingBuses[activeEditingBusIndex].selectedMainItem = item.dataset.value;
        
        // 更新編輯界面以反映項目計數變化
        updateBusEditingInterface();
        updateEditingTabs();
      }
    });
  }
  
  // 添加更多需要的事件委派
  // ...
}
// 改進的網絡請求函數，支持重試、超時和更好的錯誤處理
async function fetchWithRetry(url, options = {}, retries = 3, delay = 1000) {
  // 添加請求超時功能
  let timeoutController;
  let timeoutId;
  
  // 如果瀏覽器支持 AbortController
  if (typeof AbortController !== 'undefined') {
    timeoutController = new AbortController();
    const timeoutMs = options.timeout || 15000; // 默認15秒超時
    
    // 設置超時取消
    timeoutId = setTimeout(() => {
      timeoutController.abort();
    }, timeoutMs);
    
    // 合併原有的 signal 和新建的 signal
    if (options.signal) {
      const originalSignal = options.signal;
      const abort = () => timeoutController.abort();
      originalSignal.addEventListener('abort', abort);
      
      // 清理函數
      const cleanup = () => originalSignal.removeEventListener('abort', abort);
      
      timeoutController.signal.addEventListener('abort', cleanup);
    }
    
    // 將 signal 添加到 options
    options = {
      ...options,
      signal: timeoutController.signal
    };
  }
  
  try {
    const response = await fetch(url, options);
    
    // 清除超時
    if (timeoutId) clearTimeout(timeoutId);
    
    // 如果響應成功直接返回
    if (response.ok) return response;
    
    // 如果是401錯誤，可能是身份驗證問題
    if (response.status === 401) {
      showStatusMessage("身份驗證失敗，請重新登錄", "error", true);
      throw new Error(`身份驗證錯誤: ${response.status}`);
    }
    
    // 如果是5xx服務器錯誤且還有重試次數，則重試
    if (response.status >= 500 && retries > 1) {
      console.log(`服務器錯誤 ${response.status}，${retries-1}次重試剩餘，等待${delay}ms...`);
      await new Promise(resolve => setTimeout(resolve, delay));
      return fetchWithRetry(url, options, retries - 1, delay * 1.5);
    }
    
    // 其他錯誤，嘗試獲取詳細錯誤信息
    let errorMessage;
    try {
      const errorData = await response.json();
      errorMessage = errorData.message || errorData.error || `HTTP錯誤 ${response.status}`;
    } catch (e) {
      errorMessage = `HTTP錯誤 ${response.status}`;
    }
    
    throw new Error(errorMessage);
  } catch (err) {
    // 清除超時
    if (timeoutId) clearTimeout(timeoutId);
    
    // 處理中斷錯誤
    if (err.name === 'AbortError') {
      throw new Error('請求超時，請檢查網絡連接');
    }
    
    // 處理網絡錯誤
    if (err.message.includes('Network') && retries > 1) {
      console.log(`網絡錯誤，${retries-1}次重試剩餘，等待${delay}ms...`, err);
      await new Promise(resolve => setTimeout(resolve, delay));
      return fetchWithRetry(url, options, retries - 1, delay * 1.5);
    }
    
    // 無法進一步重試
    if (retries <= 1) {
      // 提供更友好的錯誤信息
      let userMessage;
      if (err.message.includes('Network')) {
        userMessage = '網絡連接錯誤，請檢查網絡後重試';
      } else if (err.message.includes('timeout')) {
        userMessage = '請求超時，服務器響應過慢';
      } else {
        userMessage = `請求錯誤: ${err.message}`;
      }
      
      console.error(userMessage, err);
      throw new Error(userMessage);
    }
    
    // 繼續重試
    await new Promise(resolve => setTimeout(resolve, delay));
    return fetchWithRetry(url, options, retries - 1, delay * 1.5);
  }
}
// 改進的選擇車輛函數，更好地處理狀態同步和索引管理
function selectBusForInput(bus, index, scrollToView = false) {
  logVehicleState(`開始選擇車輛-${bus.plateNumber}`);
  
  // 防止重複選擇正在處理中的車輛
  if (isProcessingBus && bus.uniqueId && editingBuses.some(editBus => editBus.uniqueId === bus.uniqueId)) {
    console.log(`車輛 ${bus.plateNumber} 已在編輯中，直接滾動到編輯區域`);
    
    // 找到編輯中的索引
    const editIndex = editingBuses.findIndex(editBus => editBus.uniqueId === bus.uniqueId);
    if (editIndex !== -1) {
      activeEditingBusIndex = editIndex;
      // 更新編輯界面和標籤
      updateEditingTabs();
      updateBusEditingInterface();
    }
    
    if (scrollToView) {
      scrollToEditingArea();
    }
    return;
  }
  
  // 確保有唯一ID，如果沒有則創建
  if (!bus.uniqueId) {
    bus.uniqueId = uuid.v4();
    
    // 檢查索引有效性
    if (index !== undefined && index >= 0 && index < displayedBuses.length) {
      displayedBuses[index].uniqueId = bus.uniqueId;
    }
    
    // 嘗試在全局列表中找到對應車輛並同步ID
    const globalIndex = allDetectedBuses.findIndex(item => 
      item.plateNumber === bus.plateNumber && 
      item.operatorName === bus.operatorName
    );
    
    if (globalIndex !== -1) {
      allDetectedBuses[globalIndex].uniqueId = bus.uniqueId;
    }
    
    console.log(`創建新唯一ID: ${bus.uniqueId}`);
  }
  
  // 明確記錄這台車輛在顯示列表中的索引
  const originalIndex = index;
  
  // 查找是否已在編輯列表中 - 使用唯一ID精確匹配
  let existingIndex = editingBuses.findIndex(item => item.uniqueId === bus.uniqueId);
  
  let busToEdit;
  if (existingIndex !== -1) {
    // 已存在於編輯列表，切換到該編輯視圖
    activeEditingBusIndex = existingIndex;
    busToEdit = editingBuses[existingIndex];
    
    // 確保記錄原始索引
    busToEdit.originalIndex = originalIndex;
    
    console.log(`找到已編輯車輛，索引: ${existingIndex}, ID: ${busToEdit.uniqueId}`);
  } else {
    // 創建新的編輯項
    busToEdit = JSON.parse(JSON.stringify(bus)); // 深拷貝
    busToEdit.selectedOtherItems = busToEdit.selectedOtherItems || [];
    busToEdit.originalPlateNumber = bus.plateNumber;
    
    // 明確記錄原始顯示列表索引
    busToEdit.originalIndex = originalIndex;
    
    console.log(`創建新編輯車輛，原始索引: ${originalIndex}, ID: ${busToEdit.uniqueId}`);
    
    // 標記基礎資料來源列表中的車輛為正在編輯
    if (displayedBuses[originalIndex] && displayedBuses[originalIndex].uniqueId === bus.uniqueId) {
      displayedBuses[originalIndex].isInEditing = true;
    }
    
    // 查找並標記全局列表中的對應車輛
    if (bus.uniqueId) {
      const globalBus = allDetectedBuses.find(item => item.uniqueId === bus.uniqueId);
      if (globalBus) {
        globalBus.isInEditing = true;
      }
    }
    
    editingBuses.push(busToEdit);
    activeEditingBusIndex = editingBuses.length - 1;
  }
  
  // 設置處理狀態
  isProcessingBus = true;
  
  // 更新介面
  updateBusEditingInterface();
  document.getElementById("busInputContainer").classList.remove("hidden");
  updateBusSelectionInList();
  
  if (scrollToView) {
    scrollToEditingArea();
  }
  
  // 同步編輯狀態
  syncEditingStatus();
  
  // 重置提交按鈕狀態
  resetSubmitButtonState();
}
// 改進的記錄提交函數，更好地處理項目分類和錯誤處理
async function submitBusRecord(bus, index, mainItem, selectedOtherItems) {
  showLoading();
  
  try {
    // 確保有選擇主要項目
    if (!mainItem) {
      showStatusMessage("請選擇查核結果", "error");
      hideLoading();
      return Promise.reject(new Error("未選擇查核結果"));
    }
    
    // 確保 selectedOtherItems 是數組
    let itemsArray = [];
    
    if (Array.isArray(selectedOtherItems)) {
      itemsArray = [...selectedOtherItems]; // 建立副本
    } else if (typeof selectedOtherItems === 'string') {
      // 處理逗號分隔的字符串
      itemsArray = selectedOtherItems.split(',')
        .map(item => item.trim())
        .filter(item => item.length > 0);
    } else if (selectedOtherItems && typeof selectedOtherItems === 'object') {
      // 處理對象形式
      try {
        itemsArray = Object.values(selectedOtherItems).filter(item => item);
      } catch (e) {
        console.error("解析selectedOtherItems對象失敗:", e);
        itemsArray = [];
      }
    }
    
    console.log("處理後的選中項目數組:", itemsArray);
    
    // 定義正向和負向項目數組
    const positiveItems = [];
    const negativeItems = [];
    const unclassifiedItems = [];
    
    // 使用 Map 緩存項目類型，避免重複查詢
    const itemTypeCache = new Map();
    
    // 遍歷所有選中的項目，進行分類
    for (let i = 0; i < itemsArray.length; i++) {
      const itemName = itemsArray[i];
      if (!itemName) continue; // 跳過空白項目
      
      // 檢查緩存中是否已有此項目類型
      if (itemTypeCache.has(itemName)) {
        const cachedType = itemTypeCache.get(itemName);
        
        if (cachedType === "positive") {
          positiveItems.push(itemName);
        } else if (cachedType === "negative") {
          negativeItems.push(itemName);
        } else {
          unclassifiedItems.push(itemName);
        }
        
        continue;
      }
      
      // 在 otherItems 中查找對應項目
      let foundItem = null;
      
      // 確保 otherItems 存在且是數組
      if (Array.isArray(otherItems) && otherItems.length > 0) {
        foundItem = otherItems.find(item => 
          item && item.itemName === itemName
        );
      }
      
      if (foundItem) {
        // 使用輔助函數檢查項目類型
        const itemType = logItemClassification(itemName, foundItem);
        
        // 緩存結果
        itemTypeCache.set(itemName, itemType);
        
        if (itemType === "positive") {
          console.log(`✅ 確認 "${itemName}" 為正向項目，加入 goodItem`);
          positiveItems.push(itemName);
        } else if (itemType === "negative") {
          console.log(`❌ 確認 "${itemName}" 為負向項目，加入 otherItem`);
          negativeItems.push(itemName);
        } else {
          console.log(`⚠️ 項目 "${itemName}" 類型無法確定，加入 otherItem`);
          unclassifiedItems.push(itemName);
        }
      } else {
        // 找不到對應項目的情況
        console.log(`⚠️ 無法在 otherItems 中找到項目 "${itemName}"，加入 otherItem`);
        unclassifiedItems.push(itemName);
        
        // 緩存結果
        itemTypeCache.set(itemName, null);
      }
    }
    
    // 將未分類項目加入負向項目列表
    const finalNegativeItems = [...negativeItems, ...unclassifiedItems];
    
    // 構建最終新增數據
    const submissionData = {
      userId: document.getElementById("userId").value,
      location: document.getElementById("location").value,
      plateNumbCompany: bus.operatorName || "不明",
      routeName: bus.routeName?.chinese || "不明",
      plateNumber: bus.plateNumber,
      direction: bus.direction || "0",
      positionLat: `(${bus.position?.latitude || currentLatitude},${
        bus.position?.longitude || currentLongitude
      })`,
      mainItem: mainItem,
      otherItem: finalNegativeItems.join(", "), // 負向項目和未分類項目
      goodItem: positiveItems.join(", ")        // 正向項目
    };
    
    // 詳細記錄最終新增的數據
    console.log("最終新增數據:", JSON.stringify(submissionData, null, 2));
    console.log("正向項目(goodItem):", positiveItems);
    console.log("負向項目(otherItem):", finalNegativeItems);
    
    // 發送請求
    const response = await fetchWithRetry(
      `${base_url}monitor/records`,
      {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(submissionData),
        timeout: 20000 // 20秒超時
      },
      3 // 3次重試
    );
    
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(errorText || `HTTP錯誤 ${response.status}`);
    }
    
    // 處理成功響應
    const data = await response.json();
    console.log("新增成功，服務器響應:", data);
    
    // 更新UI和本地存儲
    handleSubmitSuccess(bus);
    
    return Promise.resolve(data);
  } catch (error) {
    console.error("新增失敗:", error);
    showFloatingNotification(`新增失敗: ${error.message}`, "error");
    return Promise.reject(error);
  } finally {
    hideLoading();
  }
}
// 改進的同步編輯狀態函數，確保所有相關列表保持一致
function syncEditingStatus() {
  console.log("同步編輯狀態...");
  
  try {
    // 收集所有編輯中車輛的唯一ID
    const editingIds = new Set(editingBuses.map(bus => bus.uniqueId));
    
    // 更新所有顯示列表和全局列表中的編輯狀態
    displayedBuses.forEach(bus => {
      // 檢查是否有有效的唯一ID
      if (!bus.uniqueId) {
        console.warn(`警告: 顯示列表中找到沒有唯一ID的車輛: ${bus.plateNumber}`);
        return;
      }
      
      // 更新編輯狀態
      const wasEditing = bus.isInEditing;
      bus.isInEditing = editingIds.has(bus.uniqueId);
      
      // 如果狀態有變化，記錄變化
      if (wasEditing !== bus.isInEditing) {
        console.log(`車輛 ${bus.plateNumber} (ID: ${bus.uniqueId}) 編輯狀態變更: ${wasEditing} -> ${bus.isInEditing}`);
      }
    });
    
    allDetectedBuses.forEach(bus => {
      if (!bus.uniqueId) {
        console.warn(`警告: 全局列表中找到沒有唯一ID的車輛: ${bus.plateNumber}`);
        return;
      }
      
      bus.isInEditing = editingIds.has(bus.uniqueId);
    });
    
    // 更新UI，反映編輯狀態
    updateBusSelectionInList();
    
    return true;
  } catch (error) {
    console.error("同步編輯狀態時發生錯誤:", error);
    return false;
  }
}
// 改進的浮動通知系統，支持隊列和多種通知類型
const NotificationSystem = {
  queue: [],
  isShowing: false,
  notificationElement: null,
  
  // 初始化通知系統
  init: function() {
    // 檢查通知元素是否存在
    this.notificationElement = document.getElementById("floatingNotification");
    
    // 如果不存在，創建一個
    if (!this.notificationElement) {
      this.notificationElement = document.createElement("div");
      this.notificationElement.id = "floatingNotification";
      this.notificationElement.className = "floating-notification";
      document.body.appendChild(this.notificationElement);
    }
    
    return this;
  },
  
  // 顯示通知
  show: function(message, type = "info", duration = 4000) {
    // 確保初始化
    this.init();
    
    // 添加到隊列
    this.queue.push({
      message,
      type,
      duration
    });
    
    // 如果當前沒有顯示通知，開始顯示
    if (!this.isShowing) {
      this.processQueue();
    }
    
    return this;
  },
  
  // 處理通知隊列
  processQueue: function() {
    if (this.queue.length === 0) {
      this.isShowing = false;
      return;
    }
    
    // 取出下一個通知
    const notification = this.queue.shift();
    this.isShowing = true;
    
    // 設置通知內容和樣式
    this.notificationElement.textContent = notification.message;
    this.notificationElement.className = "floating-notification"; // 重置類
    this.notificationElement.classList.add(notification.type);
    
    // 顯示通知
    this.notificationElement.classList.add("show");
    
    // 設置自動隱藏
    setTimeout(() => {
      this.notificationElement.classList.remove("show");
      
      // 等待動畫完成後處理下一個通知
      setTimeout(() => {
        this.processQueue();
      }, 300);
    }, notification.duration);
  },
  
  // 快捷方法
  success: function(message, duration = 4000) {
    return this.show(message, "success", duration);
  },
  
  error: function(message, duration = 5000) {
    return this.show(message, "error", duration);
  },
  
  info: function(message, duration = 4000) {
    return this.show(message, "info", duration);
  },
  
  warning: function(message, duration = 4500) {
    return this.show(message, "warning", duration);
  }
};

// 替代原有的 showFloatingNotification 函數
function showFloatingNotification(message, type, duration) {
  NotificationSystem.show(message, type, duration);
}
// 性能監控和日誌系統，幫助診斷問題
const PerformanceMonitor = {
  metrics: {},
  startTimes: {},
  
  // 開始測量
  start: function(name) {
    this.startTimes[name] = performance.now();
    return this;
  },
  
  // 結束測量
  end: function(name) {
    if (!this.startTimes[name]) {
      console.warn(`未找到 ${name} 的開始時間`);
      return this;
    }
    
    const duration = performance.now() - this.startTimes[name];
    
    // 保存測量結果
    if (!this.metrics[name]) {
      this.metrics[name] = {
        count: 0,
        totalDuration: 0,
        minDuration: duration,
        maxDuration: duration
      };
    }
    
    const metric = this.metrics[name];
    metric.count++;
    metric.totalDuration += duration;
    metric.minDuration = Math.min(metric.minDuration, duration);
    metric.maxDuration = Math.max(metric.maxDuration, duration);
    
    // 輸出詳細日誌，只在開發環境
    if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
      console.log(`${name} 耗時: ${duration.toFixed(2)}ms`);
    }
    
    delete this.startTimes[name];
    return this;
  },
  
  // 獲取指標報告
  getReport: function() {
    const report = {};
    
    Object.keys(this.metrics).forEach(name => {
      const metric = this.metrics[name];
      report[name] = {
        count: metric.count,
        avgDuration: metric.totalDuration / metric.count,
        minDuration: metric.minDuration,
        maxDuration: metric.maxDuration
      };
    });
    
    return report;
  },
  
  // 輸出報告到控制台
  printReport: function() {
    console.group('性能監控報告');
    
    const report = this.getReport();
    Object.keys(report).forEach(name => {
      const { count, avgDuration, minDuration, maxDuration } = report[name];
      console.log(`${name}: ${count}次調用, 平均${avgDuration.toFixed(2)}ms, 最小${minDuration.toFixed(2)}ms, 最大${maxDuration.toFixed(2)}ms`);
    });
    
    console.groupEnd();
    return this;
  },
  
  // 重置指標
  reset: function() {
    this.metrics = {};
    this.startTimes = {};
    return this;
  }
};

// 高級日誌系統
const Logger = {
  // 日誌級別
  LogLevel: {
    DEBUG: 0,
    INFO: 1,
    WARN: 2,
    ERROR: 3
  },
  
  currentLevel: 1, // 默認INFO級別
  
  // 設置日誌級別
  setLevel: function(level) {
    this.currentLevel = level;
    return this;
  },
  
  // 不同級別的日誌方法
  debug: function(...args) {
    if (this.currentLevel <= this.LogLevel.DEBUG) {
      console.debug('[DEBUG]', ...args);
    }
    return this;
  },
  
  info: function(...args) {
    if (this.currentLevel <= this.LogLevel.INFO) {
      console.info('[INFO]', ...args);
    }
    return this;
  },
  
  warn: function(...args) {
    if (this.currentLevel <= this.LogLevel.WARN) {
      console.warn('[WARN]', ...args);
    }
    return this;
  },
  
  error: function(...args) {
    if (this.currentLevel <= this.LogLevel.ERROR) {
      console.error('[ERROR]', ...args);
    }
    return this;
  },
  
  // 功能性日誌方法
  api: function(method, url, status, duration) {
    if (this.currentLevel <= this.LogLevel.INFO) {
      const statusColor = status >= 200 && status < 300 ? 'green' : 'red';
      console.log(
        `%c[API] %c${method} %c${url} %c${status} %c${duration.toFixed(2)}ms`,
        'color: gray',
        'color: blue',
        'color: black',
        `color: ${statusColor}`,
        'color: purple'
      );
    }
    return this;
  },
  
  performance: function(operation, duration) {
    if (this.currentLevel <= this.LogLevel.DEBUG) {
      console.log(
        `%c[PERF] %c${operation}: %c${duration.toFixed(2)}ms`,
        'color: gray',
        'color: black',
        'color: blue'
      );
    }
    return this;
  },
  
  // 車輛操作日誌
  vehicle: function(operation, plateNumber, details = {}) {
    if (this.currentLevel <= this.LogLevel.INFO) {
      console.log(
        `%c[車輛] %c${operation}: %c${plateNumber}`,
        'color: gray',
        'color: black',
        'color: blue',
        details
      );
    }
    return this;
  }
};
// 事件防抖與節流工具，用於優化頻繁觸發的事件
const EventOptimizer = {
  // 防抖函數：延遲執行函數，如果在延遲期間再次調用則重新計時
  debounce: function(func, wait = 300, immediate = false) {
    let timeout;
    
    return function(...args) {
      const context = this;
      
      const later = function() {
        timeout = null;
        if (!immediate) func.apply(context, args);
      };
      
      const callNow = immediate && !timeout;
      
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      
      if (callNow) func.apply(context, args);
    };
  },
  
  // 節流函數：限制函數在一定時間內只能執行一次
  throttle: function(func, limit = 300) {
    let inThrottle;
    let lastFunc;
    let lastRan;
    
    return function(...args) {
      const context = this;
      
      if (!inThrottle) {
        func.apply(context, args);
        lastRan = Date.now();
        inThrottle = true;
      } else {
        clearTimeout(lastFunc);
        
        lastFunc = setTimeout(function() {
          if (Date.now() - lastRan >= limit) {
            func.apply(context, args);
            lastRan = Date.now();
          }
        }, limit - (Date.now() - lastRan));
      }
    };
  },
  
  // 防彈函數：結合防抖和節流，保證最小執行間隔同時也會延遲執行
  bulletproof: function(func, wait = 300, limit = 1000) {
    let timeout;
    let lastRan = 0;
    
    return function(...args) {
      const context = this;
      
      clearTimeout(timeout);
      
      const now = Date.now();
      const timeSinceLastRun = now - lastRan;
      
      if (timeSinceLastRun > limit) {
        // 如果超過限制時間，立即執行
        lastRan = now;
        func.apply(context, args);
      } else {
        // 否則設置延遲執行
        timeout = setTimeout(function() {
          lastRan = Date.now();
          func.apply(context, args);
        }, wait);
      }
    };
  }
};

// 使用優化器重新定義關鍵函數
const debouncedInitMarquees = EventOptimizer.debounce(initializeMarquees, 200);
const throttledUpdateBusSelectionInList = EventOptimizer.throttle(updateBusSelectionInList, 300);
const bulletproofDetectBuses = EventOptimizer.bulletproof(detectBuses, 300, 2000);
</script>
</html>
